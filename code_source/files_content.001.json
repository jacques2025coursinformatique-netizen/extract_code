{
    "extract_code.spec": "# -*- mode: python ; coding: utf-8 -*-\n\n\na = Analysis(\n    ['main.py'],\n    pathex=[],\n    binaries=[],\n    datas=[],\n    hiddenimports=[],\n    hookspath=[],\n    hooksconfig={},\n    runtime_hooks=[],\n    excludes=[],\n    noarchive=False,\n    optimize=0,\n)\npyz = PYZ(a.pure)\n\nexe = EXE(\n    pyz,\n    a.scripts,\n    a.binaries,\n    a.datas,\n    [],\n    name='extract_code',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    upx_exclude=[],\n    runtime_tmpdir=None,\n    console=False,\n    disable_windowed_traceback=False,\n    argv_emulation=False,\n    target_arch=None,\n    codesign_identity=None,\n    entitlements_file=None,\n)\n",
    "main.py": "from tkinter import Tk\nfrom interface.ui import ApplicationUI\n\n\ndef main():\n    root = Tk()\n    app = ApplicationUI(root)\n    root.mainloop()\n\n\nif __name__ == \"__main__\":\n    main()",
    "requirements.txt": "tk\npyinstaller",
    "data\\models.py": "import os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Set, Optional\n\n\nDEFAULT_EXCLUDES = [\"venv\", \"code_source\", \"archive\", \".env\",\".venv\",\".git\",\"__pycache__\",\".python-version\",\"dist\",\"build\",\"main.spec\"]\n\n\n@dataclass\nclass ProjectPaths:\n    root: str\n\n    @property\n    def code_source(self) -> str:\n        return os.path.join(self.root, \"code_source\")\n\n    @property\n    def exclude_file(self) -> str:\n        return os.path.join(self.code_source, \"exclude.txt\")\n\n    def organisation_json(self, version: str) -> str:\n        return os.path.join(self.code_source, f\"organisation.{version}.json\")\n\n    def files_content_json(self, version: str) -> str:\n        return os.path.join(self.code_source, f\"files_content.{version}.json\")\n\n    @property\n    def context_md(self) -> str:\n        return os.path.join(self.code_source, \"context.md\")\n\n    @property\n    def context_html(self) -> str:\n        return os.path.join(self.code_source, \"context.html\")\n\n    @property\n    def selected_context_md(self) -> str:\n        return os.path.join(self.code_source, \"selected_context.md\")\n\n    @property\n    def selected_context_html(self) -> str:\n        return os.path.join(self.code_source, \"selected_context.html\")\n\n\n@dataclass\nclass FileEntry:\n    relative_path: str\n    content: str\n\n\n@dataclass\nclass ProjectSnapshot:\n    version: str\n    organisation: Dict[str, Dict[str, List[str]]]\n    files_content: Dict[str, str]\n\n\n@dataclass\nclass ExclusionRules:\n    defaults: Set[str] = field(default_factory=lambda: set(DEFAULT_EXCLUDES))\n    custom: Set[str] = field(default_factory=set)\n\n    def all(self) -> Set[str]:\n        return self.defaults.union(self.custom)\n\n    def should_exclude(self, name: str) -> bool:\n        for ex in self.all():\n            if name == ex or name.startswith(ex):\n                return True\n        return False\n",
    "data\\utils.py": "import os\nimport json\nfrom typing import Dict, List, Tuple\nfrom .models import ProjectSnapshot\n\n\ndef load_json(path: str) -> Dict:\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n\n\ndef save_json(path: str, data: Dict) -> None:\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=4, ensure_ascii=False)\n\n\ndef list_existing_versions(code_source_dir: str) -> List[str]:\n    if not os.path.isdir(code_source_dir):\n        return []\n    versions = set()\n    for name in os.listdir(code_source_dir):\n        if name.startswith(\"organisation.\") and name.endswith(\".json\"):\n            middle = name[len(\"organisation.\"):-len(\".json\")]\n            versions.add(middle)\n    return sorted(versions)\n\n\ndef get_next_version_number(code_source_dir: str) -> str:\n    versions = list_existing_versions(code_source_dir)\n    if not versions:\n        return \"001\"\n    last = max(int(v) for v in versions)\n    return f\"{last + 1:03d}\"\n\n\ndef delete_version_files(code_source_dir: str, version: str) -> None:\n    org = os.path.join(code_source_dir, f\"organisation.{version}.json\")\n    fc = os.path.join(code_source_dir, f\"files_content.{version}.json\")\n    for path in (org, fc):\n        if os.path.exists(path):\n            os.remove(path)\n\n\ndef generate_markdown(snapshot: ProjectSnapshot) -> str:\n    md = \"# Organisation du projet\\n\\n\"\n    for folder, content in snapshot.organisation.items():\n        md += f\"## {folder}\\n\"\n        md += \"**Dossiers :**\\n\"\n        for d in content.get(\"dirs\", []):\n            md += f\"- {d}\\n\"\n        md += \"\\n**Fichiers :**\\n\"\n        for f in content.get(\"files\", []):\n            md += f\"- {f}\\n\"\n        md += \"\\n---\\n\"\n\n    md += \"\\n# Contenu des fichiers\\n\\n\"\n    for filepath, text in snapshot.files_content.items():\n        md += f\"## {filepath}\\n\\n\"\n        md += \"```text\\n\"\n        md += text\n        md += \"\\n```\\n\\n\"\n    return md\n\n\ndef generate_html(snapshot: ProjectSnapshot) -> str:\n    html = [\n        \"<html>\",\n        \"<head><meta charset='utf-8'><title>Context</title></head>\",\n        \"<body>\",\n        \"<h1>Organisation du projet</h1>\",\n    ]\n    for folder, content in snapshot.organisation.items():\n        html.append(f\"<h2>{folder}</h2>\")\n        html.append(\"<h3>Dossiers :</h3><ul>\")\n        for d in content.get(\"dirs\", []):\n            html.append(f\"<li>{d}</li>\")\n        html.append(\"</ul>\")\n        html.append(\"<h3>Fichiers :</h3><ul>\")\n        for f in content.get(\"files\", []):\n            html.append(f\"<li>{f}</li>\")\n        html.append(\"</ul><hr>\")\n\n    html.append(\"<h1>Contenu des fichiers</h1>\")\n    for filepath, text in snapshot.files_content.items():\n        html.append(f\"<h2>{filepath}</h2>\")\n        html.append(\"<pre>\")\n        html.append(escape_html(text))\n        html.append(\"</pre>\")\n    html.append(\"</body></html>\")\n    return \"\\n\".join(html)\n\n\ndef escape_html(text: str) -> str:\n    return (\n        text.replace(\"&\", \"&amp;\")\n        .replace(\"<\", \"&lt;\")\n        .replace(\">\", \"&gt;\")\n    )\n\n\ndef filter_snapshot(snapshot: ProjectSnapshot, selected_files: List[str]) -> ProjectSnapshot:\n    selected_set = set(selected_files)\n    filtered_files = {\n        path: content\n        for path, content in snapshot.files_content.items()\n        if path in selected_set\n    }\n\n    filtered_org: Dict[str, Dict[str, List[str]]] = {}\n    for folder, content in snapshot.organisation.items():\n        files = [f for f in content.get(\"files\", []) if os.path.join(folder, f) in selected_set]\n        if files:\n            filtered_org[folder] = {\n                \"dirs\": content.get(\"dirs\", []),\n                \"files\": files,\n            }\n\n    return ProjectSnapshot(\n        version=snapshot.version,\n        organisation=filtered_org,\n        files_content=filtered_files,\n    )\n",
    "data\\__init__.py": "",
    "interface\\ui.py": "import os\nfrom tkinter import (\n    Tk,\n    Frame,\n    Button,\n    Label,\n    Listbox,\n    Scrollbar,\n    SINGLE,\n    MULTIPLE,\n    END,\n    filedialog,\n    messagebox,\n    RIGHT,\n    LEFT,\n    Y,\n    BOTH,\n    Text,\n)\nfrom tkinter import ttk\nfrom src.client_logic import ClientLogic\n\n\nclass ApplicationUI:\n    def __init__(self, root: Tk):\n        self.root = root\n        self.root.title(\"Gestion de contexte projet\")\n\n        # --- Activation d'un thème moderne ---\n        style = ttk.Style()\n        style.theme_use(\"clam\")\n\n        self.client = ClientLogic()\n\n        self.frame_left = Frame(root)\n        self.frame_right = Frame(root)\n\n        self.preview_text = None  # zone de prévisualisation\n\n        self._build_layout()\n\n    def _build_layout(self):\n        self.frame_left.pack(side=\"left\", fill=\"both\", expand=True, padx=10, pady=10)\n        self.frame_right.pack(side=\"right\", fill=\"both\", expand=True, padx=10, pady=10)\n\n        # -------------------------\n        # COLONNE GAUCHE\n        # -------------------------\n        Label(self.frame_left, text=\"Projet\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n        ttk.Button(self.frame_left, text=\"Sélectionner un dossier\", command=self.on_select_project).pack(pady=5)\n        ttk.Button(self.frame_left, text=\"Ouvrir le dossier sélectionné\", command=self.on_open_folder).pack(pady=5)\n\n        Label(self.frame_left, text=\"Extraction complète\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n        ttk.Button(self.frame_left, text=\"Extraire l'ensemble du projet\", command=self.on_extract_full).pack(pady=5)\n\n        Label(self.frame_left, text=\"Versions disponibles\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        # --- Frame versions + scrollbar ---\n        frame_versions = Frame(self.frame_left)\n        frame_versions.pack(fill=\"both\", expand=True)\n\n        self.list_versions = Listbox(frame_versions, selectmode=SINGLE, height=10)\n        self.list_versions.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_versions = Scrollbar(frame_versions, orient=\"vertical\", command=self.list_versions.yview)\n        scroll_versions.pack(side=RIGHT, fill=Y)\n\n        self.list_versions.config(yscrollcommand=scroll_versions.set)\n        self.list_versions.bind(\"<<ListboxSelect>>\", self.on_select_version)\n\n        ttk.Button(self.frame_left, text=\"Restaurer la version sélectionnée\", command=self.on_restore_full).pack(pady=5)\n        ttk.Button(self.frame_left, text=\"Supprimer la version sélectionnée\", command=self.on_delete_version).pack(pady=5)\n\n        # -------------------------\n        # COLONNE DROITE\n        # -------------------------\n        Label(self.frame_right, text=\"Fichiers de la version sélectionnée\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        # --- Frame files + scrollbar ---\n        frame_files = Frame(self.frame_right)\n        frame_files.pack(fill=\"both\", expand=False)\n\n        self.list_files = Listbox(frame_files, selectmode=MULTIPLE, height=12)\n        self.list_files.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_files = Scrollbar(frame_files, orient=\"vertical\", command=self.list_files.yview)\n        scroll_files.pack(side=RIGHT, fill=Y)\n\n        self.list_files.config(yscrollcommand=scroll_files.set)\n        self.list_files.bind(\"<<ListboxSelect>>\", self.on_file_selected)\n\n        # -------------------------\n        # PRÉVISUALISATION\n        # -------------------------\n        Label(self.frame_right, text=\"Prévisualisation du fichier\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_preview = Frame(self.frame_right)\n        frame_preview.pack(fill=\"both\", expand=True)\n\n        self.preview_text = Text(frame_preview, wrap=\"word\", height=20)\n        self.preview_text.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_preview = Scrollbar(frame_preview, orient=\"vertical\", command=self.preview_text.yview)\n        scroll_preview.pack(side=RIGHT, fill=Y)\n\n        self.preview_text.config(yscrollcommand=scroll_preview.set)\n\n        # -------------------------\n        # ACTIONS SUR LES FICHIERS\n        # -------------------------\n        ttk.Button(self.frame_right, text=\"Créer selected_context.md & .html\", command=self.on_export_selected).pack(pady=5)\n        ttk.Button(self.frame_right, text=\"Restaurer les fichiers sélectionnés\", command=self.on_restore_selected).pack(pady=5)\n\n    # -------------------------\n    # ACTIONS COLONNE GAUCHE\n    # -------------------------\n\n    def on_select_project(self):\n        folder = filedialog.askdirectory()\n        if not folder:\n            return\n        self.client.select_project(folder)\n        messagebox.showinfo(\"Projet sélectionné\", f\"Dossier : {folder}\")\n        self.refresh_versions()\n\n    def on_open_folder(self):\n        try:\n            self.client.open_project_folder()\n        except Exception as e:\n            messagebox.showerror(\"Erreur\", str(e))\n\n    def on_extract_full(self):\n        if not self.client.has_project():\n            messagebox.showerror(\"Erreur\", \"Aucun projet sélectionné.\")\n            return\n        version = self.client.extract_full_project()\n        messagebox.showinfo(\"Extraction terminée\", f\"Version créée : {version}\")\n        self.refresh_versions()\n        self.select_version_in_list(version)\n\n    def refresh_versions(self):\n        self.list_versions.delete(0, END)\n        versions = self.client.get_available_versions()\n        for v in versions:\n            self.list_versions.insert(END, v)\n\n    def on_select_version(self, event=None):\n        selection = self.list_versions.curselection()\n        if not selection:\n            return\n        index = selection[0]\n        version = self.list_versions.get(index)\n        self.client.select_version(version)\n        self.refresh_files()\n\n    def on_restore_full(self):\n        try:\n            self.client.restore_full_version()\n            messagebox.showinfo(\"Restauration\", \"Restauration complète effectuée.\")\n        except Exception as e:\n            messagebox.showerror(\"Erreur\", str(e))\n\n    def on_delete_version(self):\n        self.client.delete_selected_version()\n        self.refresh_versions()\n        self.list_files.delete(0, END)\n        self.preview_text.delete(1.0, END)\n\n    # -------------------------\n    # ACTIONS COLONNE DROITE\n    # -------------------------\n\n    def refresh_files(self):\n        self.list_files.delete(0, END)\n        files = self.client.get_files_from_selected_version()\n        for f in files:\n            self.list_files.insert(END, f)\n        self.preview_text.delete(1.0, END)\n\n    def on_file_selected(self, event=None):\n        selection = self.list_files.curselection()\n        if not selection:\n            self.preview_text.delete(1.0, END)\n            return\n\n        index = selection[0]\n        filename = self.list_files.get(index)\n\n        snapshot = self.client.server.load_snapshot(self.client.selected_version)\n        content = snapshot.files_content.get(filename, \"\")\n\n        self.preview_text.delete(1.0, END)\n        self.preview_text.insert(END, content)\n\n    def on_export_selected(self):\n        selected_indices = self.list_files.curselection()\n        files = [self.list_files.get(i) for i in selected_indices]\n        self.client.set_selected_files(files)\n        self.client.export_selected_markdown_and_html()\n        messagebox.showinfo(\"Export\", \"selected_context.md et selected_context.html générés.\")\n\n    def on_restore_selected(self):\n        selected_indices = self.list_files.curselection()\n        files = [self.list_files.get(i) for i in selected_indices]\n        self.client.set_selected_files(files)\n        self.client.restore_selected_files()\n        messagebox.showinfo(\"Restauration\", \"Fichiers sélectionnés restaurés.\")\n\n    # -------------------------\n    # HELPERS\n    # -------------------------\n\n    def select_version_in_list(self, version: str):\n        for i in range(self.list_versions.size()):\n            if self.list_versions.get(i) == version:\n                self.list_versions.selection_clear(0, END)\n                self.list_versions.selection_set(i)\n                self.list_versions.activate(i)\n                self.on_select_version()\n                break\n",
    "interface\\__init__.py": "",
    "src\\client_logic.py": "import os\nimport subprocess\nfrom typing import List, Optional\nfrom src.server_logic import ServerLogic\n\n\nclass ClientLogic:\n    def __init__(self):\n        self.project_root: Optional[str] = None\n        self.server: Optional[ServerLogic] = None\n        self.selected_version: Optional[str] = None\n        self.selected_files: List[str] = []\n\n    # ---------- Projet ----------\n\n    def select_project(self, path: str) -> None:\n        self.project_root = path\n        self.server = ServerLogic(path)\n\n    def has_project(self) -> bool:\n        return self.server is not None\n\n    def open_project_folder(self) -> None:\n        if not self.project_root:\n            return\n        if os.name == \"nt\":  # Windows\n            os.startfile(self.project_root)\n        elif os.name == \"posix\":  # macOS / Linux\n            subprocess.Popen([\"open\" if sys.platform == \"darwin\" else \"xdg-open\", self.project_root])\n\n    # ---------- Extraction ----------\n\n    def extract_full_project(self) -> str:\n        if not self.server:\n            raise RuntimeError(\"Aucun projet sélectionné.\")\n        snapshot = self.server.scan_project()\n        self.server.save_snapshot(snapshot)\n        self.server.export_full_context(snapshot)\n        self.selected_version = snapshot.version\n        return snapshot.version\n\n    # ---------- Versions ----------\n\n    def get_available_versions(self) -> List[str]:\n        if not self.server:\n            return []\n        return self.server.list_versions()\n\n    def select_version(self, version: str) -> None:\n        self.selected_version = version\n\n    def delete_selected_version(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        self.server.delete_version(self.selected_version)\n        self.selected_version = None\n\n    # ---------- Fichiers ----------\n\n    def get_files_from_selected_version(self) -> List[str]:\n        if not self.server or not self.selected_version:\n            return []\n        snapshot = self.server.load_snapshot(self.selected_version)\n        return sorted(snapshot.files_content.keys())\n\n    def set_selected_files(self, files: List[str]) -> None:\n        self.selected_files = files\n\n    # ---------- Export sélection ----------\n\n    def export_selected_markdown_and_html(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.export_selected_context(snapshot, self.selected_files)\n\n    # ---------- Restauration ----------\n\n    def restore_full_version(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.restore_all(snapshot)\n\n    def restore_selected_files(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.restore_selected(snapshot, self.selected_files)\n",
    "src\\server_logic.py": "import os\nfrom typing import List, Dict, Tuple\nfrom data.models import ProjectPaths, ExclusionRules, ProjectSnapshot\nfrom data.utils import (\n    save_json,\n    load_json,\n    generate_markdown,\n    generate_html,\n    get_next_version_number,\n    list_existing_versions,\n    delete_version_files,\n)\n\n\nclass ServerLogic:\n    def __init__(self, project_root: str):\n        self.paths = ProjectPaths(project_root)\n        self.exclusions = ExclusionRules()\n        self._ensure_code_source()\n\n    # ---------- Initialisation / exclusions ----------\n\n    def _ensure_code_source(self) -> None:\n        os.makedirs(self.paths.code_source, exist_ok=True)\n        if not os.path.exists(self.paths.exclude_file):\n            with open(self.paths.exclude_file, \"w\", encoding=\"utf-8\") as f:\n                f.write(\"\\n\".join(sorted(self.exclusions.defaults)))\n\n    def load_exclusions(self) -> None:\n        self.exclusions.custom.clear()\n        if os.path.exists(self.paths.exclude_file):\n            with open(self.paths.exclude_file, \"r\", encoding=\"utf-8\") as f:\n                for line in f:\n                    line = line.strip()\n                    if line:\n                        self.exclusions.custom.add(line)\n\n    # ---------- Scan / snapshot ----------\n\n    def scan_project(self) -> ProjectSnapshot:\n        self.load_exclusions()\n        organisation: Dict[str, Dict[str, List[str]]] = {}\n        files_content: Dict[str, str] = {}\n\n        for current_root, dirs, files in os.walk(self.paths.root):\n            rel_root = os.path.relpath(current_root, self.paths.root)\n            if rel_root == \".\":\n                rel_root = \"\"\n\n            dirs[:] = [d for d in dirs if not self.exclusions.should_exclude(d)]\n\n            organisation[rel_root] = {\n                \"dirs\": dirs.copy(),\n                \"files\": [f for f in files if not self.exclusions.should_exclude(f)],\n            }\n\n            for f in files:\n                if self.exclusions.should_exclude(f):\n                    continue\n                rel_path = os.path.join(rel_root, f) if rel_root else f\n                file_path = os.path.join(current_root, f)\n                try:\n                    with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as fp:\n                        files_content[rel_path] = fp.read()\n                except Exception:\n                    files_content[rel_path] = \"<< Impossible de lire ce fichier >>\"\n\n        version = get_next_version_number(self.paths.code_source)\n        return ProjectSnapshot(version=version, organisation=organisation, files_content=files_content)\n\n    # ---------- Sauvegarde / chargement snapshot ----------\n\n    def save_snapshot(self, snapshot: ProjectSnapshot) -> None:\n        save_json(self.paths.organisation_json(snapshot.version), snapshot.organisation)\n        save_json(self.paths.files_content_json(snapshot.version), snapshot.files_content)\n\n    def load_snapshot(self, version: str) -> ProjectSnapshot:\n        org = load_json(self.paths.organisation_json(version))\n        fc = load_json(self.paths.files_content_json(version))\n        return ProjectSnapshot(version=version, organisation=org, files_content=fc)\n\n    # ---------- Exports ----------\n\n    def export_full_context(self, snapshot: ProjectSnapshot) -> None:\n        md = generate_markdown(snapshot)\n        html = generate_html(snapshot)\n        with open(self.paths.context_md, \"w\", encoding=\"utf-8\") as f:\n            f.write(md)\n        with open(self.paths.context_html, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n\n    def export_selected_context(self, snapshot: ProjectSnapshot, selected_files: List[str]) -> None:\n        from data.utils import filter_snapshot\n        filtered = filter_snapshot(snapshot, selected_files)\n        md = generate_markdown(filtered)\n        html = generate_html(filtered)\n        with open(self.paths.selected_context_md, \"w\", encoding=\"utf-8\") as f:\n            f.write(md)\n        with open(self.paths.selected_context_html, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n\n    # ---------- Versioning ----------\n\n    def list_versions(self) -> List[str]:\n        return list_existing_versions(self.paths.code_source)\n\n    def delete_version(self, version: str) -> None:\n        delete_version_files(self.paths.code_source, version)\n\n    # ---------- Restauration ----------\n\n    def restore_all(self, snapshot: ProjectSnapshot) -> None:\n        for rel_path, content in snapshot.files_content.items():\n            abs_path = os.path.join(self.paths.root, rel_path)\n            os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n            with open(abs_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n    def restore_selected(self, snapshot: ProjectSnapshot, selected_files: List[str]) -> None:\n        selected_set = set(selected_files)\n        for rel_path, content in snapshot.files_content.items():\n            if rel_path not in selected_set:\n                continue\n            abs_path = os.path.join(self.paths.root, rel_path)\n            os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n            with open(abs_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)",
    "src\\__init__.py": ""
}