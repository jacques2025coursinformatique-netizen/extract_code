{
    "extract_code.spec": "# -*- mode: python ; coding: utf-8 -*-\n\n\na = Analysis(\n    ['main.py'],\n    pathex=[],\n    binaries=[],\n    datas=[],\n    hiddenimports=[],\n    hookspath=[],\n    hooksconfig={},\n    runtime_hooks=[],\n    excludes=[],\n    noarchive=False,\n    optimize=0,\n)\npyz = PYZ(a.pure)\n\nexe = EXE(\n    pyz,\n    a.scripts,\n    a.binaries,\n    a.datas,\n    [],\n    name='extract_code',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    upx_exclude=[],\n    runtime_tmpdir=None,\n    console=False,\n    disable_windowed_traceback=False,\n    argv_emulation=False,\n    target_arch=None,\n    codesign_identity=None,\n    entitlements_file=None,\n)\n",
    "main.py": "from tkinter import Tk\nfrom interface.ui import ApplicationUI\n\n\ndef main():\n    root = Tk()\n    app = ApplicationUI(root)\n    root.mainloop()\n\n\nif __name__ == \"__main__\":\n    main()",
    "requirements.txt": "tk\npyinstaller",
    ".vscode\\launch.json": "{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n    \n        {\n            \"name\": \"Python Debugger: Current File\",\n            \"type\": \"debugpy\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/main.py\",\n            \"console\": \"integratedTerminal\"\n        }\n    ]\n}",
    "data\\categories.json": "{\n    \"categories\": [\n        \"Mon essai\",\n        \"eSSAI 2\"\n    ]\n}",
    "data\\models.py": "import os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Set, Optional\n\n\nDEFAULT_EXCLUDES = [\"venv\", \"code_source\", \"archive\", \".env\",\".venv\",\".git\",\"__pycache__\",\".python-version\",\"dist\",\"build\",\"main.spec\"]\n\n\n@dataclass\nclass ProjectPaths:\n    root: str\n\n    @property\n    def code_source(self) -> str:\n        return os.path.join(self.root, \"code_source\")\n\n    @property\n    def exclude_file(self) -> str:\n        return os.path.join(self.code_source, \"exclude.txt\")\n\n    def organisation_json(self, version: str) -> str:\n        return os.path.join(self.code_source, f\"organisation.{version}.json\")\n\n    def files_content_json(self, version: str) -> str:\n        return os.path.join(self.code_source, f\"files_content.{version}.json\")\n\n    @property\n    def context_md(self) -> str:\n        return os.path.join(self.code_source, \"context.md\")\n\n    @property\n    def context_html(self) -> str:\n        return os.path.join(self.code_source, \"context.html\")\n\n    @property\n    def selected_context_md(self) -> str:\n        return os.path.join(self.code_source, \"selected_context.md\")\n\n    @property\n    def selected_context_html(self) -> str:\n        return os.path.join(self.code_source, \"selected_context.html\")\n\n\n@dataclass\nclass FileEntry:\n    relative_path: str\n    content: str\n\n\n@dataclass\nclass ProjectSnapshot:\n    version: str\n    organisation: Dict[str, Dict[str, List[str]]]\n    files_content: Dict[str, str]\n\n\n@dataclass\nclass ExclusionRules:\n    defaults: Set[str] = field(default_factory=lambda: set(DEFAULT_EXCLUDES))\n    custom: Set[str] = field(default_factory=set)\n\n    def all(self) -> Set[str]:\n        return self.defaults.union(self.custom)\n\n    def should_exclude(self, name: str) -> bool:\n        for ex in self.all():\n            if name == ex or name.startswith(ex):\n                return True\n        return False\n",
    "data\\queries.json": "{\n    \"queries\": [\n        {\n            \"name\": \"Essai\",\n            \"description\": \"Ma dexcription\",\n            \"category\": \"Mon essai\",\n            \"context_files\": \"@file1\",\n            \"versions\": [\n                {\n                    \"version\": \"001\",\n                    \"before\": \"frerg\",\n                    \"after\": \"fgfg\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Essai 2\",\n            \"description\": \"fsdgdgbdf\",\n            \"category\": \"eSSAI 2\",\n            \"context_files\": \"\",\n            \"versions\": [\n                {\n                    \"version\": \"001\",\n                    \"before\": \"gghrthrt\",\n                    \"after\": \"trhtrshtrshrs\"\n                }\n            ]\n        }\n    ]\n}",
    "data\\queries_manager.py": "import json\nimport os\nfrom typing import Dict, List, Optional, Any\n\n\nclass QueriesManager:\n    \"\"\"\n    Gestion des fichiers :\n    - data/categories.json : liste de valeurs possibles pour le champ \"category\"\n    - data/queries.json : liste de requêtes complètes\n    \"\"\"\n\n    def __init__(self, base_dir: Optional[str] = None):\n        if base_dir is None:\n            data_dir = os.path.dirname(os.path.abspath(__file__))  # .../data\n        else:\n            if os.path.basename(base_dir) == \"data\":\n                data_dir = base_dir\n            else:\n                data_dir = os.path.join(base_dir, \"data\")\n\n        self.categories_path = os.path.join(data_dir, \"categories.json\")\n        self.queries_path = os.path.join(data_dir, \"queries.json\")\n\n        self.categories: List[str] = []\n        self.queries: List[Dict[str, Any]] = []\n\n        self.load_all()\n\n    # ------------------------------------------------------------------ #\n    # Chargement / sauvegarde\n    # ------------------------------------------------------------------ #\n\n    def load_all(self) -> None:\n        self.categories = self._load_categories(self.categories_path)\n        self.queries = self._load_queries(self.queries_path)\n\n    def save_all(self) -> None:\n        self._save_categories(self.categories_path, self.categories)\n        self._save_queries(self.queries_path, self.queries)\n\n    def _load_categories(self, path: str) -> List[str]:\n        if not os.path.exists(path):\n            return []\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n        if isinstance(data, dict) and \"categories\" in data:\n            return list(data[\"categories\"])\n        if isinstance(data, list):\n            return data\n        return []\n\n    def _save_categories(self, path: str, categories: List[str]) -> None:\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            json.dump({\"categories\": categories}, f, indent=4, ensure_ascii=False)\n\n    def _load_queries(self, path: str) -> List[Dict[str, Any]]:\n        if not os.path.exists(path):\n            return []\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n        if isinstance(data, dict) and \"queries\" in data:\n            return list(data[\"queries\"])\n        if isinstance(data, list):\n            return data\n        return []\n\n    def _save_queries(self, path: str, queries: List[Dict[str, Any]]) -> None:\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            json.dump({\"queries\": queries}, f, indent=4, ensure_ascii=False)\n\n    # ------------------------------------------------------------------ #\n    # Catégories (liste de valeurs possibles)\n    # ------------------------------------------------------------------ #\n\n    def get_categories(self) -> List[str]:\n        return list(self.categories)\n\n    def add_category(self, name: str) -> None:\n        if name and name not in self.categories:\n            self.categories.append(name)\n            self.save_all()\n\n    def delete_category(self, name: str) -> None:\n        if name in self.categories:\n            self.categories.remove(name)\n            self.save_all()\n\n    def rename_category(self, old: str, new: str) -> None:\n        if old in self.categories and new:\n            idx = self.categories.index(old)\n            self.categories[idx] = new\n            self.save_all()\n\n    # ------------------------------------------------------------------ #\n    # Requêtes\n    # ------------------------------------------------------------------ #\n\n    def get_all_query_names(self) -> List[str]:\n        return [q.get(\"name\", \"\") for q in self.queries]\n\n    def get_query(self, name: str) -> Optional[Dict[str, Any]]:\n        for q in self.queries:\n            if q.get(\"name\") == name:\n                return q\n        return None\n\n    def add_query(self, name: str) -> None:\n        if not name:\n            return\n        if self.get_query(name) is not None:\n            return\n        self.queries.append(\n            {\n                \"name\": name,\n                \"description\": \"\",\n                \"category\": \"\",\n                \"context_files\": \"\",\n                \"versions\": [],\n            }\n        )\n        self.save_all()\n\n    def delete_query(self, name: str) -> None:\n        before = len(self.queries)\n        self.queries = [q for q in self.queries if q.get(\"name\") != name]\n        if len(self.queries) != before:\n            self.save_all()\n\n    def update_query_fields(\n        self,\n        old_name: str,\n        new_name: str,\n        category: str,\n        description: str,\n        context_files: str,\n    ) -> None:\n        q = self.get_query(old_name)\n        if not q:\n            return\n        q[\"name\"] = new_name or old_name\n        q[\"category\"] = category or \"\"\n        q[\"description\"] = description or \"\"\n        q[\"context_files\"] = context_files or \"\"\n        self.save_all()\n\n    # ------------------------------------------------------------------ #\n    # Versions\n    # ------------------------------------------------------------------ #\n\n    def get_versions_for_query(self, query_name: str) -> List[str]:\n        q = self.get_query(query_name)\n        if not q:\n            return []\n        return [v.get(\"version\", \"\") for v in q.get(\"versions\", [])]\n\n    def get_version(self, query_name: str, version_number: str) -> Optional[Dict[str, Any]]:\n        q = self.get_query(query_name)\n        if not q:\n            return None\n        for v in q.get(\"versions\", []):\n            if v.get(\"version\") == version_number:\n                return v\n        return None\n\n    def add_version(self, query_name: str, version_number: str) -> None:\n        q = self.get_query(query_name)\n        if not q or not version_number:\n            return\n        versions = q.setdefault(\"versions\", [])\n        for v in versions:\n            if v.get(\"version\") == version_number:\n                return\n        versions.append(\n            {\n                \"version\": version_number,\n                \"before\": \"\",\n                \"after\": \"\",\n            }\n        )\n        self.save_all()\n\n    def delete_version(self, query_name: str, version_number: str) -> None:\n        q = self.get_query(query_name)\n        if not q:\n            return\n        versions = q.get(\"versions\", [])\n        new_versions = [v for v in versions if v.get(\"version\") != version_number]\n        if len(new_versions) != len(versions):\n            q[\"versions\"] = new_versions\n            self.save_all()\n\n    def update_version(\n        self,\n        query_name: str,\n        old_version: str,\n        new_version: str,\n        before: str,\n        after: str,\n    ) -> None:\n        q = self.get_query(query_name)\n        if not q:\n            return\n        versions = q.setdefault(\"versions\", [])\n        for v in versions:\n            if v.get(\"version\") == old_version:\n                v[\"version\"] = new_version or old_version\n                v[\"before\"] = before or \"\"\n                v[\"after\"] = after or \"\"\n                self.save_all()\n                return\n",
    "data\\utils.py": "import os\nimport json\nfrom typing import Dict, List, Tuple\nfrom .models import ProjectSnapshot\n\n\ndef load_json(path: str) -> Dict:\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n\n\ndef save_json(path: str, data: Dict) -> None:\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=4, ensure_ascii=False)\n\n\ndef list_existing_versions(code_source_dir: str) -> List[str]:\n    if not os.path.isdir(code_source_dir):\n        return []\n    versions = set()\n    for name in os.listdir(code_source_dir):\n        if name.startswith(\"organisation.\") and name.endswith(\".json\"):\n            middle = name[len(\"organisation.\"):-len(\".json\")]\n            versions.add(middle)\n    return sorted(versions)\n\n\ndef get_next_version_number(code_source_dir: str) -> str:\n    versions = list_existing_versions(code_source_dir)\n    if not versions:\n        return \"001\"\n    last = max(int(v) for v in versions)\n    return f\"{last + 1:03d}\"\n\n\ndef delete_version_files(code_source_dir: str, version: str) -> None:\n    org = os.path.join(code_source_dir, f\"organisation.{version}.json\")\n    fc = os.path.join(code_source_dir, f\"files_content.{version}.json\")\n    for path in (org, fc):\n        if os.path.exists(path):\n            os.remove(path)\n\n\ndef generate_markdown(snapshot: ProjectSnapshot) -> str:\n    md = \"# Organisation du projet\\n\\n\"\n    for folder, content in snapshot.organisation.items():\n        md += f\"## {folder}\\n\"\n        md += \"**Dossiers :**\\n\"\n        for d in content.get(\"dirs\", []):\n            md += f\"- {d}\\n\"\n        md += \"\\n**Fichiers :**\\n\"\n        for f in content.get(\"files\", []):\n            md += f\"- {f}\\n\"\n        md += \"\\n---\\n\"\n\n    md += \"\\n# Contenu des fichiers\\n\\n\"\n    for filepath, text in snapshot.files_content.items():\n        md += f\"## {filepath}\\n\\n\"\n        md += \"```text\\n\"\n        md += text\n        md += \"\\n```\\n\\n\"\n    return md\n\n\ndef generate_html(snapshot: ProjectSnapshot) -> str:\n    \"\"\"\n    Version adaptée à Copilot :\n    - HTML simple, non échappé\n    - structure proche du Markdown\n    - lisible comme un document texte dans Edge\n    \"\"\"\n    parts: List[str] = []\n    parts.append(\"<!DOCTYPE html>\")\n    parts.append(\"<html>\")\n    parts.append(\"<head><meta charset='utf-8'><title>Context</title></head>\")\n    parts.append(\"<body>\")\n    parts.append(\"<h1>Organisation du projet</h1>\")\n\n    for folder, content in snapshot.organisation.items():\n        parts.append(f\"<h2>{folder}</h2>\")\n        parts.append(\"<h3>Dossiers :</h3><ul>\")\n        for d in content.get(\"dirs\", []):\n            parts.append(f\"<li>{d}</li>\")\n        parts.append(\"</ul>\")\n        parts.append(\"<h3>Fichiers :</h3><ul>\")\n        for f in content.get(\"files\", []):\n            parts.append(f\"<li>{f}</li>\")\n        parts.append(\"</ul><hr>\")\n\n    parts.append(\"<h1>Contenu des fichiers</h1>\")\n    for filepath, text in snapshot.files_content.items():\n        parts.append(f\"<h2>{filepath}</h2>\")\n        parts.append(\"<pre>\")\n        parts.append(text)\n        parts.append(\"</pre>\")\n\n    parts.append(\"</body></html>\")\n    return \"\\n\".join(parts)\n\n\ndef escape_html(text: str) -> str:\n    # Gardée pour compatibilité éventuelle, mais plus utilisée dans generate_html\n    return (\n        text.replace(\"&\", \"&amp;\")\n        .replace(\"<\", \"&lt;\")\n        .replace(\">\", \"&gt;\")\n    )\n\n\ndef filter_snapshot(snapshot: ProjectSnapshot, selected_files: List[str]) -> ProjectSnapshot:\n    selected_set = set(selected_files)\n    filtered_files = {\n        path: content\n        for path, content in snapshot.files_content.items()\n        if path in selected_set\n    }\n\n    filtered_org: Dict[str, Dict[str, List[str]]] = {}\n    for folder, content in snapshot.organisation.items():\n        files = [f for f in content.get(\"files\", []) if os.path.join(folder, f) in selected_set]\n        if files:\n            filtered_org[folder] = {\n                \"dirs\": content.get(\"dirs\", []),\n                \"files\": files,\n            }\n\n    return ProjectSnapshot(\n        version=snapshot.version,\n        organisation=filtered_org,\n        files_content=filtered_files,\n    )\n",
    "data\\__init__.py": "",
    "interface\\ui.py": "import os\nfrom tkinter import (\n    Tk,\n    Frame,\n    Label,\n    Listbox,\n    Scrollbar,\n    SINGLE,\n    MULTIPLE,\n    END,\n    filedialog,\n    messagebox,\n    RIGHT,\n    LEFT,\n    Y,\n    BOTH,\n    Text,\n)\nfrom tkinter import ttk\n\nfrom src.client_logic import ClientLogic\n\nfrom data.queries_manager import QueriesManager\nfrom src.queries_logic import QueriesLogic\nfrom interface.ui_queries import QueriesUI\n\n\nclass ApplicationUI:\n    def __init__(self, root: Tk):\n        self.root = root\n        self.root.title(\"Gestion de contexte projet\")\n\n        # --- Thème moderne ---\n        style = ttk.Style()\n        style.theme_use(\"clam\")\n\n        self.client = ClientLogic()\n\n        # Manager / logique pour les requêtes type\n        self._init_queries_module()\n\n        # Widgets principaux\n        self.preview_text = None\n        self.list_versions = None\n        self.list_files = None\n\n        self.memo_query = None\n        self.memo_version = None\n        self.queries_logic.ui = self\n\n        self._build_layout()\n\n\n\n\n    # -------------------------------------------------------------------------\n    #  INITIALISATION MODULE REQUÊTES TYPE\n    # -------------------------------------------------------------------------\n    def _init_queries_module(self):\n        self.queries_manager = QueriesManager()\n\n        def copy_to_clipboard(text: str):\n            self.root.clipboard_clear()\n            self.root.clipboard_append(text)\n\n        def get_selected_files():\n            return self.get_selected_files()\n\n        self.queries_logic = QueriesLogic(\n            manager=self.queries_manager,\n            copy_to_clipboard=copy_to_clipboard,\n            get_selected_files=get_selected_files,\n        )\n\n        self.queries_ui = None  # sera créé dans le layout\n\n    # -------------------------------------------------------------------------\n    #  LAYOUT GLOBAL : PANEDWINDOW + NOTEBOOK + COLONNE DROITE\n    # -------------------------------------------------------------------------\n    def _build_layout(self):\n        # PanedWindow horizontal : gauche = Notebook, droite = fichiers/preview\n        paned = ttk.PanedWindow(self.root, orient=\"horizontal\")\n        paned.pack(fill=\"both\", expand=True)\n\n        # Frame gauche : Notebook\n        frame_left = Frame(paned)\n        paned.add(frame_left, weight=1)\n\n        # Frame droite : fichiers + preview\n        frame_right = Frame(paned)\n        paned.add(frame_right, weight=2)\n\n        # ---------------------------------------------------------------------\n        # NOTEBOOK À GAUCHE : Onglet Projet + Onglet Requêtes type\n        # ---------------------------------------------------------------------\n        self.notebook = ttk.Notebook(frame_left)\n        self.notebook.pack(fill=\"both\", expand=True, padx=10, pady=10)\n\n        # Onglet Projet\n        self.tab_project = Frame(self.notebook)\n        self.notebook.add(self.tab_project, text=\"Projet\")\n\n        # Onglet Requêtes type\n        self.tab_queries = Frame(self.notebook)\n        self.notebook.add(self.tab_queries, text=\"Requêtes type\")\n\n        # Construire le contenu de l’onglet Projet\n        self._build_project_tab(self.tab_project)\n\n        # Construire le contenu de l’onglet Requêtes type\n        self._build_queries_tab(self.tab_queries)\n\n        # ---------------------------------------------------------------------\n        # COLONNE DROITE : Fichiers + Prévisualisation + Actions\n        # ---------------------------------------------------------------------\n        self._build_right_column(frame_right)\n\n    # -------------------------------------------------------------------------\n    #  ONGLET PROJET\n    # -------------------------------------------------------------------------\n    def _build_project_tab(self, parent: Frame):\n        Label(parent, text=\"Projet\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n        ttk.Button(parent, text=\"Sélectionner un dossier\", command=self.on_select_project).pack(pady=5)\n        ttk.Button(parent, text=\"Ouvrir le dossier sélectionné\", command=self.on_open_folder).pack(pady=5)\n\n        Label(parent, text=\"Extraction complète\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n        ttk.Button(parent, text=\"Extraire l'ensemble du projet\", command=self.on_extract_full).pack(pady=5)\n\n        Label(parent, text=\"Versions disponibles\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_versions = Frame(parent)\n        frame_versions.pack(fill=\"both\", expand=True)\n\n        self.list_versions = Listbox(frame_versions, selectmode=SINGLE, height=10)\n        self.list_versions.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_versions = Scrollbar(frame_versions, orient=\"vertical\", command=self.list_versions.yview)\n        scroll_versions.pack(side=RIGHT, fill=Y)\n\n        self.list_versions.config(yscrollcommand=scroll_versions.set)\n        self.list_versions.bind(\"<<ListboxSelect>>\", self.on_select_version)\n\n        ttk.Button(parent, text=\"Restaurer la version sélectionnée\", command=self.on_restore_full).pack(pady=5)\n        ttk.Button(parent, text=\"Supprimer la version sélectionnée\", command=self.on_delete_version).pack(pady=5)\n\n    # -------------------------------------------------------------------------\n    #  ONGLET REQUÊTES TYPE\n    # -------------------------------------------------------------------------\n    def _build_queries_tab(self, parent: Frame):\n        # On insère directement QueriesUI dans cet onglet\n        self.queries_ui = QueriesUI(\n            parent,\n            manager=self.queries_manager,\n            logic=self.queries_logic,\n        )\n        self.queries_ui.pack(fill=\"both\", expand=True, padx=5, pady=5)\n\n    # -------------------------------------------------------------------------\n    #  COLONNE DROITE : FICHIERS + PRÉVISUALISATION + ACTIONS\n    # -------------------------------------------------------------------------\n    def _build_right_column(self, parent: Frame):\n        Label(parent, text=\"Fichiers de la version sélectionnée\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_files = Frame(parent)\n        frame_files.pack(fill=\"both\", expand=False, padx=10, pady=5)\n\n        self.list_files = Listbox(frame_files, selectmode=MULTIPLE, height=12)\n        self.list_files.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_files = Scrollbar(frame_files, orient=\"vertical\", command=self.list_files.yview)\n        scroll_files.pack(side=RIGHT, fill=Y)\n\n        self.list_files.config(yscrollcommand=scroll_files.set)\n        self.list_files.bind(\"<<ListboxSelect>>\", self.on_file_selected)\n\n        Label(parent, text=\"Prévisualisation du fichier\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_preview = Frame(parent)\n        frame_preview.pack(fill=\"both\", expand=True, padx=10, pady=5)\n\n        self.preview_text = Text(frame_preview, wrap=\"word\", height=20)\n        self.preview_text.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_preview = Scrollbar(frame_preview, orient=\"vertical\", command=self.preview_text.yview)\n        scroll_preview.pack(side=RIGHT, fill=Y)\n\n        self.preview_text.config(yscrollcommand=scroll_preview.set)\n\n        ttk.Button(parent, text=\"Créer selected_context.md & .html\", command=self.on_export_selected).pack(pady=5)\n        ttk.Button(parent, text=\"Restaurer les fichiers sélectionnés\", command=self.on_restore_selected).pack(pady=5)\n        ttk.Button(parent, text=\"Mémoriser la sélection\", command=self.on_memorize_selection).pack(pady=5)\n\n\n    # -------------------------------------------------------------------------\n    #  ACTIONS ONGLET PROJET\n    # -------------------------------------------------------------------------\n    def on_select_project(self):\n        folder = filedialog.askdirectory()\n        if not folder:\n            return\n        self.client.select_project(folder)\n        messagebox.showinfo(\"Projet sélectionné\", f\"Dossier : {folder}\")\n        self.refresh_versions()\n\n    def on_open_folder(self):\n        try:\n            self.client.open_project_folder()\n        except Exception as e:\n            messagebox.showerror(\"Erreur\", str(e))\n\n    def on_extract_full(self):\n        if not self.client.has_project():\n            messagebox.showerror(\"Erreur\", \"Aucun projet sélectionné.\")\n            return\n        version = self.client.extract_full_project()\n        messagebox.showinfo(\"Extraction terminée\", f\"Version créée : {version}\")\n        self.refresh_versions()\n        self.select_version_in_list(version)\n\n    def refresh_versions(self):\n        if self.list_versions is None:\n            return\n        self.list_versions.delete(0, END)\n        versions = self.client.get_available_versions()\n        for v in versions:\n            self.list_versions.insert(END, v)\n\n    def on_select_version(self, event=None):\n        selection = self.list_versions.curselection()\n        if not selection:\n            return\n        index = selection[0]\n        version = self.list_versions.get(index)\n        self.client.select_version(version)\n        self.refresh_files()\n\n    def on_restore_full(self):\n        try:\n            self.client.restore_full_version()\n            messagebox.showinfo(\"Restauration\", \"Restauration complète effectuée.\")\n        except Exception as e:\n            messagebox.showerror(\"Erreur\", str(e))\n\n    def on_delete_version(self):\n        self.client.delete_selected_version()\n        self.refresh_versions()\n        if self.list_files is not None:\n            self.list_files.delete(0, END)\n        if self.preview_text is not None:\n            self.preview_text.delete(1.0, END)\n\n    # -------------------------------------------------------------------------\n    #  ACTIONS COLONNE DROITE\n    # -------------------------------------------------------------------------\n    def refresh_files(self):\n        if self.list_files is None:\n            return\n        self.list_files.delete(0, END)\n        files = self.client.get_files_from_selected_version()\n        for f in files:\n            self.list_files.insert(END, f)\n        if self.preview_text is not None:\n            self.preview_text.delete(1.0, END)\n\n    def on_file_selected(self, event=None):\n        selection = self.list_files.curselection()\n        if not selection:\n            self.preview_text.delete(1.0, END)\n            return\n\n        index = selection[0]\n        filename = self.list_files.get(index)\n\n        snapshot = self.client.server.load_snapshot(self.client.selected_version)\n        content = snapshot.files_content.get(filename, \"\")\n\n        self.preview_text.delete(1.0, END)\n        self.preview_text.insert(END, content)\n\n    def on_export_selected(self):\n        selected_indices = self.list_files.curselection()\n        files = [self.list_files.get(i) for i in selected_indices]\n        self.client.set_selected_files(files)\n        self.client.export_selected_markdown_and_html()\n        messagebox.showinfo(\"Export\", \"selected_context.md et selected_context.html générés.\")\n\n    def on_restore_selected(self):\n        selected_indices = self.list_files.curselection()\n        files = [self.list_files.get(i) for i in selected_indices]\n        self.client.set_selected_files(files)\n        self.client.restore_selected_files()\n        messagebox.showinfo(\"Restauration\", \"Fichiers sélectionnés restaurés.\")\n\n    def on_memorize_selection(self):\n        if self.queries_ui is None:\n            messagebox.showerror(\"Erreur\", \"L’onglet Requêtes type n’est pas prêt.\")\n            return\n\n        query, version = self.queries_ui.get_current_query_and_version()\n\n        if not (query and version):\n            messagebox.showerror(\"Erreur\", \"Sélectionnez une requête et une version dans l’onglet Requêtes type.\")\n            return\n\n        self.memo_query = query\n        self.memo_version = version\n\n        messagebox.showinfo(\"Sélection mémorisée\", f\"Requête : {query}\\nVersion : {version}\")\n\n\n    # -------------------------------------------------------------------------\n    #  HELPERS\n    # -------------------------------------------------------------------------\n    def get_selected_files(self):\n        \"\"\"\n        Utilisé par QueriesLogic pour récupérer les fichiers sélectionnés\n        dans la colonne droite.\n        \"\"\"\n        if self.list_files is None:\n            return []\n        selected_indices = self.list_files.curselection()\n        return [self.list_files.get(i) for i in selected_indices]\n\n    def select_version_in_list(self, version: str):\n        if self.list_versions is None:\n            return\n        for i in range(self.list_versions.size()):\n            if self.list_versions.get(i) == version:\n                self.list_versions.selection_clear(0, END)\n                self.list_versions.selection_set(i)\n                self.list_versions.activate(i)\n                self.on_select_version()\n                break\n",
    "interface\\ui_queries.py": "from tkinter import (\n    Frame, Label, Listbox, Scrollbar, SINGLE, END, BOTH, LEFT, RIGHT, Y,\n    Text, StringVar\n)\nfrom tkinter import ttk, filedialog, messagebox\n\nfrom data.queries_manager import QueriesManager\n\n\nclass QueriesUI(Frame):\n    def __init__(self, parent, manager: QueriesManager, logic):\n        super().__init__(parent)\n        self.manager = manager\n        self.logic = logic\n\n        # Sélections courantes\n        self.current_query = None\n        self.current_version = None\n\n        # Flag pour éviter les callbacks parasites sur les versions\n        self._lock_versions = False\n\n        # Variables UI\n        self.var_query_name = StringVar()\n        self.var_category = StringVar()\n        self.var_version = StringVar()\n        self.var_context_files = StringVar()\n\n        self._build_ui()\n\n        # Tous les widgets existent maintenant → on peut rafraîchir\n        self._refresh_categories()\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    # ------------------------------------------------------------------ #\n    # CONSTRUCTION UI\n    # ------------------------------------------------------------------ #\n\n    def _build_ui(self):\n        main = ttk.PanedWindow(self, orient=\"horizontal\")\n        main.pack(fill=BOTH, expand=True)\n\n        left = Frame(main)\n        right = Frame(main)\n        main.add(left, weight=1)\n        main.add(right, weight=2)\n\n        # ============================\n        #  FORMULAIRE COMPLET À DROITE\n        # ============================\n        Label(right, text=\"Nom de la requête\", font=(\"Segoe UI\", 10, \"bold\")).pack(anchor=\"w\", pady=2)\n        self.entry_query_name = ttk.Entry(right, textvariable=self.var_query_name)\n        self.entry_query_name.pack(fill=\"x\", padx=5, pady=2)\n\n        Label(right, text=\"Catégorie\", font=(\"Segoe UI\", 10, \"bold\")).pack(anchor=\"w\", pady=2)\n        self.combo_category = ttk.Combobox(right, textvariable=self.var_category, state=\"normal\")\n        self.combo_category.pack(fill=\"x\", padx=5, pady=2)\n\n        Label(right, text=\"Description\", font=(\"Segoe UI\", 10, \"bold\")).pack(anchor=\"w\", pady=2)\n        frame_desc = Frame(right)\n        frame_desc.pack(fill=BOTH, expand=False, padx=5, pady=2)\n        self.text_description = Text(frame_desc, height=4, wrap=\"word\")\n        self.text_description.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_desc = Scrollbar(frame_desc, command=self.text_description.yview)\n        scroll_desc.pack(side=RIGHT, fill=Y)\n        self.text_description.config(yscrollcommand=scroll_desc.set)\n\n        Label(right, text=\"Context files (@file1 @file2 ...)\", font=(\"Segoe UI\", 10, \"bold\")).pack(anchor=\"w\", pady=2)\n        self.entry_context_files = ttk.Entry(right, textvariable=self.var_context_files)\n        self.entry_context_files.pack(fill=\"x\", padx=5, pady=2)\n\n        Label(right, text=\"Numéro de version\", font=(\"Segoe UI\", 10, \"bold\")).pack(anchor=\"w\", pady=2)\n        self.entry_version = ttk.Entry(right, textvariable=self.var_version)\n        self.entry_version.pack(fill=\"x\", padx=5, pady=2)\n\n        Label(right, text=\"Before\", font=(\"Segoe UI\", 10, \"bold\")).pack(anchor=\"w\", pady=2)\n        frame_before = Frame(right)\n        frame_before.pack(fill=BOTH, expand=True, padx=5, pady=2)\n        self.text_before = Text(frame_before, height=8, wrap=\"word\")\n        self.text_before.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_before = Scrollbar(frame_before, command=self.text_before.yview)\n        scroll_before.pack(side=RIGHT, fill=Y)\n        self.text_before.config(yscrollcommand=scroll_before.set)\n\n        Label(right, text=\"After\", font=(\"Segoe UI\", 10, \"bold\")).pack(anchor=\"w\", pady=2)\n        frame_after = Frame(right)\n        frame_after.pack(fill=BOTH, expand=True, padx=5, pady=2)\n        self.text_after = Text(frame_after, height=8, wrap=\"word\")\n        self.text_after.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_after = Scrollbar(frame_after, command=self.text_after.yview)\n        scroll_after.pack(side=RIGHT, fill=Y)\n        self.text_after.config(yscrollcommand=scroll_after.set)\n\n        btn_save = Frame(right)\n        btn_save.pack(fill=\"x\", pady=4)\n        ttk.Button(btn_save, text=\"Enregistrer requête + version\", command=self._on_save_all).pack(side=LEFT, padx=2)\n\n        btn_gen = Frame(right)\n        btn_gen.pack(fill=\"x\", pady=4)\n        ttk.Button(btn_gen, text=\"Copier requête GitHub\", command=self._on_generate_github).pack(side=LEFT, padx=2)\n        ttk.Button(btn_gen, text=\"Copier requête Edge\", command=self._on_generate_edge).pack(side=LEFT, padx=2)\n\n        # ============================\n        #  SECTION CATÉGORIES\n        # ============================\n        frame_cat = Frame(left)\n        frame_cat.pack(fill=BOTH, expand=False, padx=5, pady=5)\n\n        Label(frame_cat, text=\"Catégories\", font=(\"Segoe UI\", 10, \"bold\")).pack()\n\n        self.list_categories = Listbox(frame_cat, selectmode=SINGLE, height=5)\n        self.list_categories.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_cat = Scrollbar(frame_cat, command=self.list_categories.yview)\n        scroll_cat.pack(side=RIGHT, fill=Y)\n        self.list_categories.config(yscrollcommand=scroll_cat.set)\n        self.list_categories.bind(\"<<ListboxSelect>>\", self._on_category_selected)\n\n        btn_cat = Frame(left)\n        btn_cat.pack(fill=\"x\", padx=5)\n        ttk.Button(btn_cat, text=\"Ajouter\", command=self._on_add_category).pack(side=LEFT, padx=2)\n        ttk.Button(btn_cat, text=\"Modifier\", command=self._on_rename_category).pack(side=LEFT, padx=2)\n        ttk.Button(btn_cat, text=\"Supprimer\", command=self._on_delete_category).pack(side=LEFT, padx=2)\n        ttk.Button(btn_cat, text=\"Import\", command=self._on_import_categories).pack(side=LEFT, padx=2)\n        ttk.Button(btn_cat, text=\"Export\", command=self._on_export_categories).pack(side=LEFT, padx=2)\n\n        # ============================\n        #  SECTION REQUÊTES\n        # ============================\n        Label(left, text=\"Requêtes\", font=(\"Segoe UI\", 10, \"bold\")).pack(pady=4)\n\n        frame_req = Frame(left)\n        frame_req.pack(fill=BOTH, expand=True, padx=5)\n\n        self.list_queries = Listbox(frame_req, selectmode=SINGLE, height=10)\n        self.list_queries.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_req = Scrollbar(frame_req, command=self.list_queries.yview)\n        scroll_req.pack(side=RIGHT, fill=Y)\n        self.list_queries.config(yscrollcommand=scroll_req.set)\n        self.list_queries.bind(\"<<ListboxSelect>>\", self._on_query_selected)\n\n        btn_req = Frame(left)\n        btn_req.pack(fill=\"x\", padx=5, pady=2)\n        ttk.Button(btn_req, text=\"Ajouter\", command=self._on_add_query).pack(side=LEFT, padx=2)\n        ttk.Button(btn_req, text=\"Modifier\", command=self._on_rename_query).pack(side=LEFT, padx=2)\n        ttk.Button(btn_req, text=\"Supprimer\", command=self._on_delete_query).pack(side=LEFT, padx=2)\n        ttk.Button(btn_req, text=\"Import\", command=self._on_import_queries).pack(side=LEFT, padx=2)\n        ttk.Button(btn_req, text=\"Export\", command=self._on_export_queries).pack(side=LEFT, padx=2)\n\n        # ============================\n        #  SECTION VERSIONS\n        # ============================\n        Label(left, text=\"Versions\", font=(\"Segoe UI\", 10, \"bold\")).pack(pady=4)\n\n        frame_ver = Frame(left)\n        frame_ver.pack(fill=BOTH, expand=True, padx=5)\n\n        self.list_versions = Listbox(frame_ver, selectmode=SINGLE, height=8)\n        self.list_versions.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_ver = Scrollbar(frame_ver, command=self.list_versions.yview)\n        scroll_ver.pack(side=RIGHT, fill=Y)\n        self.list_versions.config(yscrollcommand=scroll_ver.set)\n        self.list_versions.bind(\"<<ListboxSelect>>\", self._on_version_selected)\n\n        btn_ver = Frame(left)\n        btn_ver.pack(fill=\"x\", padx=5, pady=2)\n        ttk.Button(btn_ver, text=\"Ajouter\", command=self._on_add_version).pack(side=LEFT, padx=2)\n        ttk.Button(btn_ver, text=\"Modifier\", command=self._on_rename_version).pack(side=LEFT, padx=2)\n        ttk.Button(btn_ver, text=\"Supprimer\", command=self._on_delete_version).pack(side=LEFT, padx=2)\n\n    # ------------------------------------------------------------------ #\n    # Rafraîchissements\n    # ------------------------------------------------------------------ #\n\n    def _refresh_categories(self):\n        self.list_categories.unbind(\"<<ListboxSelect>>\")\n\n        cats = self.manager.get_categories()\n        selected = self.list_categories.curselection()\n\n        self.list_categories.delete(0, END)\n        for c in cats:\n            self.list_categories.insert(END, c)\n\n        self.combo_category[\"values\"] = cats\n\n        if selected:\n            try:\n                self.list_categories.selection_set(selected[0])\n            except Exception:\n                pass\n\n        self.list_categories.bind(\"<<ListboxSelect>>\", self._on_category_selected)\n        self.list_queries.bind(\"<<ListboxSelect>>\", self._on_query_selected)\n\n    def _refresh_queries(self):\n        selected = self.current_query\n\n        self.list_queries.delete(0, END)\n        for name in self.manager.get_all_query_names():\n            self.list_queries.insert(END, name)\n\n        self._select_in_list(self.list_queries, selected)\n\n    def _refresh_versions(self):\n        self._lock_versions = True\n\n        selected = self.current_version\n\n        self.list_versions.delete(0, END)\n        if self.current_query:\n            for v in self.manager.get_versions_for_query(self.current_query):\n                self.list_versions.insert(END, v)\n\n        self._select_in_list(self.list_versions, selected)\n\n        self._lock_versions = False\n\n    def _refresh_editor(self):\n        self._lock_versions = True\n\n        # --- Requête sélectionnée ---\n        if self.current_query:\n            q = self.manager.get_query(self.current_query)\n        else:\n            q = None\n\n        if q:\n            self.var_query_name.set(q.get(\"name\", \"\"))\n            self.var_category.set(q.get(\"category\", \"\"))\n            self.var_context_files.set(q.get(\"context_files\", \"\"))\n\n            self.text_description.delete(\"1.0\", END)\n            self.text_description.insert(\"1.0\", q.get(\"description\", \"\"))\n        else:\n            self.var_query_name.set(\"\")\n            self.var_category.set(\"\")\n            self.var_context_files.set(\"\")\n            self.text_description.delete(\"1.0\", END)\n\n        # --- Version sélectionnée ---\n        if q and self.current_version:\n            v = self.manager.get_version(self.current_query, self.current_version)\n        else:\n            v = None\n\n        if v:\n            self.var_version.set(v.get(\"version\", \"\"))\n            self.text_before.delete(\"1.0\", END)\n            self.text_before.insert(\"1.0\", v.get(\"before\", \"\"))\n\n            self.text_after.delete(\"1.0\", END)\n            self.text_after.insert(\"1.0\", v.get(\"after\", \"\"))\n        else:\n            self.var_version.set(\"\")\n            self.text_before.delete(\"1.0\", END)\n            self.text_after.delete(\"1.0\", END)\n\n        # Sélection visuelle\n        self._select_in_list(self.list_queries, self.current_query)\n        self._select_in_list(self.list_versions, self.current_version)\n\n        self._lock_versions = False\n\n    def _select_in_list(self, listbox, value):\n        listbox.selection_clear(0, END)\n        if not value:\n            return\n        for i in range(listbox.size()):\n            if listbox.get(i) == value:\n                listbox.selection_set(i)\n                listbox.activate(i)\n                break\n\n    # ------------------------------------------------------------------ #\n    # Sélections\n    # ------------------------------------------------------------------ #\n\n    def _on_query_selected(self, event=None):\n        if event and event.widget is not self.list_queries:\n            return\n\n        sel = self.list_queries.curselection()\n        if not sel:\n            return\n\n        self.current_query = self.list_queries.get(sel[0])\n\n        versions = self.manager.get_versions_for_query(self.current_query)\n        self.current_version = versions[0] if versions else None\n\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_version_selected(self, event=None):\n        if self._lock_versions:\n            return\n        if event and event.widget is not self.list_versions:\n            return\n\n        sel = self.list_versions.curselection()\n        if not sel:\n            self.current_version = None\n        else:\n            self.current_version = self.list_versions.get(sel[0])\n\n        # Ici, on ne touche qu’aux champs de version, pas aux listes\n        self._lock_versions = True\n\n        if self.current_query and self.current_version:\n            v = self.manager.get_version(self.current_query, self.current_version)\n        else:\n            v = None\n\n        if v:\n            self.var_version.set(v.get(\"version\", \"\"))\n            self.text_before.delete(\"1.0\", END)\n            self.text_before.insert(\"1.0\", v.get(\"before\", \"\"))\n            self.text_after.delete(\"1.0\", END)\n            self.text_after.insert(\"1.0\", v.get(\"after\", \"\"))\n        else:\n            self.var_version.set(\"\")\n            self.text_before.delete(\"1.0\", END)\n            self.text_after.delete(\"1.0\", END)\n\n        self._lock_versions = False\n\n    # ------------------------------------------------------------------ #\n    # Actions Catégories\n    # ------------------------------------------------------------------ #\n\n    def _on_add_category(self):\n        name = self._ask_string(\"Nouvelle catégorie\", \"Nom :\")\n        if not name:\n            return\n        self.manager.add_category(name)\n        self._refresh_categories()\n\n    def _on_rename_category(self):\n        sel = self.list_categories.curselection()\n        if not sel:\n            return\n        old = self.list_categories.get(sel[0])\n        new = self._ask_string(\"Renommer catégorie\", \"Nouveau nom :\", initial=old)\n        if not new:\n            return\n        self.manager.rename_category(old, new)\n        self._refresh_categories()\n\n    def _on_delete_category(self):\n        sel = self.list_categories.curselection()\n        if not sel:\n            return\n        name = self.list_categories.get(sel[0])\n        if not messagebox.askyesno(\"Supprimer\", f\"Supprimer la catégorie '{name}' ?\"):\n            return\n        self.manager.delete_category(name)\n        self._refresh_categories()\n\n    def _on_import_categories(self):\n        path = filedialog.askopenfilename(title=\"Importer catégories\", filetypes=[(\"JSON\", \"*.json\")])\n        if not path:\n            return\n        self.manager.import_categories(path)\n        self._refresh_categories()\n\n    def _on_export_categories(self):\n        path = filedialog.asksaveasfilename(title=\"Exporter catégories\", defaultextension=\".json\")\n        if not path:\n            return\n        self.manager.export_categories(path)\n\n    def _on_category_selected(self, event=None):\n        if not self.current_query:\n            return\n        selection = self.list_categories.curselection()\n        if not selection:\n            return\n        category = self.list_categories.get(selection[0])\n        self.var_category.set(category)\n\n    # ------------------------------------------------------------------ #\n    # Actions Requêtes\n    # ------------------------------------------------------------------ #\n\n    def _on_add_query(self):\n        name = self._ask_string(\"Nouvelle requête\", \"Nom :\")\n        if not name:\n            return\n        self.manager.add_query(name)\n        self.current_query = name\n        self.current_version = None\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_rename_query(self):\n        if not self.current_query:\n            return\n        new = self._ask_string(\"Renommer requête\", \"Nouveau nom :\", initial=self.current_query)\n        if not new:\n            return\n        self.manager.update_query_fields(\n            old_name=self.current_query,\n            new_name=new,\n            category=self.var_category.get(),\n            description=self.text_description.get(\"1.0\", END).strip(),\n            context_files=self.var_context_files.get(),\n        )\n        self.current_query = new\n        self._refresh_queries()\n        self._refresh_editor()\n\n    def _on_delete_query(self):\n        if not self.current_query:\n            return\n        if not messagebox.askyesno(\"Supprimer\", f\"Supprimer la requête '{self.current_query}' ?\"):\n            return\n        self.manager.delete_query(self.current_query)\n        self.current_query = None\n        self.current_version = None\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_import_queries(self):\n        path = filedialog.askopenfilename(title=\"Importer requêtes\", filetypes=[(\"JSON\", \"*.json\")])\n        if not path:\n            return\n        self.manager.import_queries(path)\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_export_queries(self):\n        path = filedialog.asksaveasfilename(title=\"Exporter requêtes\", defaultextension=\".json\")\n        if not path:\n            return\n        self.manager.export_queries(path)\n\n    # ------------------------------------------------------------------ #\n    # Actions Versions\n    # ------------------------------------------------------------------ #\n\n    def _on_add_version(self):\n        if not self.current_query:\n            messagebox.showerror(\"Erreur\", \"Sélectionnez une requête.\")\n            return\n\n        existing = self.manager.get_versions_for_query(self.current_query)\n\n        suggested = \"001\"\n        if existing:\n            nums = []\n            for v in existing:\n                try:\n                    nums.append(int(v))\n                except ValueError:\n                    pass\n            if nums:\n                suggested = f\"{max(nums) + 1:03d}\"\n\n        version = self._ask_string(\"Nouvelle version\", \"Numéro :\", initial=suggested)\n        if not version:\n            return\n\n        self.manager.add_version(self.current_query, version)\n        self.current_version = version\n        self.var_version.set(version)\n\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_rename_version(self):\n        if not (self.current_query and self.current_version):\n            return\n        new = self._ask_string(\"Renommer version\", \"Nouveau numéro :\", initial=self.current_version)\n        if not new:\n            return\n        before = self.text_before.get(\"1.0\", END).strip()\n        after = self.text_after.get(\"1.0\", END).strip()\n        self.manager.update_version(\n            query_name=self.current_query,\n            old_version=self.current_version,\n            new_version=new,\n            before=before,\n            after=after,\n        )\n        self.current_version = new\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_delete_version(self):\n        if not (self.current_query and self.current_version):\n            return\n        if not messagebox.askyesno(\"Supprimer\", f\"Supprimer la version '{self.current_version}' ?\"):\n            return\n        self.manager.delete_version(self.current_query, self.current_version)\n        self.current_version = None\n        self._refresh_versions()\n        self._refresh_editor()\n\n    # ------------------------------------------------------------------ #\n    # ENREGISTREMENT GLOBAL\n    # ------------------------------------------------------------------ #\n\n    def _on_save_all(self):\n        if not self.current_query:\n            messagebox.showerror(\"Erreur\", \"Sélectionnez ou créez une requête.\")\n            return\n\n        old_name = self.current_query\n        new_name = self.var_query_name.get().strip()\n        category = self.var_category.get().strip()\n        description = self.text_description.get(\"1.0\", END).strip()\n        context_files = self.var_context_files.get().strip()\n\n        self.manager.update_query_fields(\n            old_name=old_name,\n            new_name=new_name or old_name,\n            category=category,\n            description=description,\n            context_files=context_files,\n        )\n        self.current_query = new_name or old_name\n\n        version_number = self.var_version.get().strip()\n        before = self.text_before.get(\"1.0\", END).strip()\n        after = self.text_after.get(\"1.0\", END).strip()\n\n        if version_number:\n            self.manager.update_version(\n                query_name=self.current_query,\n                old_version=self.current_version or version_number,\n                new_version=version_number,\n                before=before,\n                after=after,\n            )\n            self.current_version = version_number\n            self.var_version.set(version_number)\n\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    # ------------------------------------------------------------------ #\n    # GÉNÉRATION\n    # ------------------------------------------------------------------ #\n\n    def get_current_query_and_version(self):\n        return self.current_query, self.current_version\n\n\n    def _on_generate_github(self):\n        if not (self.current_query and self.current_version):\n            messagebox.showerror(\"Erreur\", \"Sélectionnez une requête et une version.\")\n            return\n\n        # Geler la sélection\n        saved_query = self.current_query\n        saved_version = self.current_version\n\n        # Appeler la génération (sans context_files)\n        self.logic.generate_github_copilot(saved_query, saved_version)\n\n        # Restaurer la sélection\n        self.current_query = saved_query\n        self.current_version = saved_version\n\n        # Rafraîchir l’UI\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n\n    def _on_generate_edge(self):\n        if not (self.current_query and self.current_version):\n            messagebox.showerror(\"Erreur\", \"Sélectionnez une requête et une version.\")\n            return\n\n        saved_query = self.current_query\n        saved_version = self.current_version\n\n        self.logic.generate_edge_copilot(saved_query, saved_version)\n\n        self.current_query = saved_query\n        self.current_version = saved_version\n\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n\n\n\n    # ------------------------------------------------------------------ #\n    # HELPERS\n    # ------------------------------------------------------------------ #\n\n    def _ask_string(self, title: str, prompt: str, initial: str = \"\"):\n        from tkinter.simpledialog import askstring\n        return askstring(title, prompt, initialvalue=initial)\n",
    "interface\\__init__.py": "",
    "src\\client_logic.py": "import os\nimport subprocess\nfrom typing import List, Optional\nfrom src.server_logic import ServerLogic\n\n\nclass ClientLogic:\n    def __init__(self):\n        self.project_root: Optional[str] = None\n        self.server: Optional[ServerLogic] = None\n        self.selected_version: Optional[str] = None\n        self.selected_files: List[str] = []\n\n    # ---------- Projet ----------\n\n    def select_project(self, path: str) -> None:\n        self.project_root = path\n        self.server = ServerLogic(path)\n\n    def has_project(self) -> bool:\n        return self.server is not None\n\n    def open_project_folder(self) -> None:\n        if not self.project_root:\n            return\n        if os.name == \"nt\":  # Windows\n            os.startfile(self.project_root)\n        elif os.name == \"posix\":  # macOS / Linux\n            subprocess.Popen([\"open\" if sys.platform == \"darwin\" else \"xdg-open\", self.project_root])\n\n    # ---------- Extraction ----------\n\n    def extract_full_project(self) -> str:\n        if not self.server:\n            raise RuntimeError(\"Aucun projet sélectionné.\")\n        snapshot = self.server.scan_project()\n        self.server.save_snapshot(snapshot)\n        self.server.export_full_context(snapshot)\n        self.selected_version = snapshot.version\n        return snapshot.version\n\n    # ---------- Versions ----------\n\n    def get_available_versions(self) -> List[str]:\n        if not self.server:\n            return []\n        return self.server.list_versions()\n\n    def select_version(self, version: str) -> None:\n        self.selected_version = version\n\n    def delete_selected_version(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        self.server.delete_version(self.selected_version)\n        self.selected_version = None\n\n    # ---------- Fichiers ----------\n\n    def get_files_from_selected_version(self) -> List[str]:\n        if not self.server or not self.selected_version:\n            return []\n        snapshot = self.server.load_snapshot(self.selected_version)\n        return sorted(snapshot.files_content.keys())\n\n    def set_selected_files(self, files: List[str]) -> None:\n        self.selected_files = files\n\n    # ---------- Export sélection ----------\n\n    def export_selected_markdown_and_html(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.export_selected_context(snapshot, self.selected_files)\n\n    # ---------- Restauration ----------\n\n    def restore_full_version(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.restore_all(snapshot)\n\n    def restore_selected_files(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.restore_selected(snapshot, self.selected_files)\n",
    "src\\queries_logic.py": "import os\nimport webbrowser\nfrom typing import List, Dict, Callable, Optional\n\nfrom data.queries_manager import QueriesManager\n\n\nclass QueriesLogic:\n    def __init__(\n        self,\n        manager: QueriesManager,\n        copy_to_clipboard: Callable[[str], None],\n        get_selected_files: Callable[[], List[str]],\n        base_path: Optional[str] = None,\n    ):\n        self.manager = manager\n        self.copy_to_clipboard = copy_to_clipboard\n        self.get_selected_files = get_selected_files\n\n        if base_path is None:\n            base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n        self.base_path = base_path\n\n        self.context_html_path = os.path.join(\n            self.base_path,\n            \"code_source\",\n            \"selected_context.html\",\n        )\n\n    # ---------- Construction des requêtes ----------\n\n    def build_edge_query(self, query: Dict, version: Dict) -> str:\n        before = version.get(\"before\", \"\").strip()\n        after = version.get(\"after\", \"\").strip()\n\n        context_block = (\n            \"Interface: the context files are available in the @selected_context tab.\"\n        )\n\n        parts = [p for p in [before, context_block, after] if p]\n        return \"\\n\\n\".join(parts)\n\n    def build_github_query(self, query: Dict, version: Dict) -> str:\n        before = version.get(\"before\", \"\").strip()\n        after = version.get(\"after\", \"\").strip()\n\n        selected_files = self.get_selected_files()\n        if selected_files:\n            context_lines = [f\"@{path}\" for path in selected_files]\n            context_block = \"Context files:\\n\" + \"\\n\".join(context_lines)\n        else:\n            context_block = \"Context files: (no files selected)\"\n\n        parts = [p for p in [before, context_block, after] if p]\n        return \"\\n\\n\".join(parts)\n\n    # ---------- Actions ----------\n\n    def open_edge_context_html(self) -> None:\n        if os.path.exists(self.context_html_path):\n            webbrowser.open(self.context_html_path)\n\n    def generate_edge_copilot(self, query_name: str, version_number: str) -> str:\n        query_name = self.ui.memo_query\n        query = self.manager.get_query(query_name)\n        if query is None:\n            return \"\"\n        \n        version_number = self.ui.memo_version\n        version = self.manager.get_version(query_name, version_number)\n        if version is None:\n            return \"\"\n        text = self.build_edge_query(query, version)\n        self.open_edge_context_html()\n        self.copy_to_clipboard(text)\n        return text\n\n    def generate_github_copilot(self, query_name: str, version_number: str) -> str:\n        query_name = self.ui.memo_query\n        query = self.manager.get_query(query_name)\n        if query is None:\n            return \"\"\n        \n        version_number = self.ui.memo_version\n        version = self.manager.get_version(query_name, version_number)\n        if version is None:\n            return \"\"\n        text = self.build_github_query(query, version)\n        self.copy_to_clipboard(text)\n        return text\n",
    "src\\server_logic.py": "import os\nfrom typing import List, Dict, Tuple\nfrom data.models import ProjectPaths, ExclusionRules, ProjectSnapshot\nfrom data.utils import (\n    save_json,\n    load_json,\n    generate_markdown,\n    generate_html,\n    get_next_version_number,\n    list_existing_versions,\n    delete_version_files,\n)\n\n\nclass ServerLogic:\n    def __init__(self, project_root: str):\n        self.paths = ProjectPaths(project_root)\n        self.exclusions = ExclusionRules()\n        self._ensure_code_source()\n\n    # ---------- Initialisation / exclusions ----------\n\n    def _ensure_code_source(self) -> None:\n        os.makedirs(self.paths.code_source, exist_ok=True)\n        if not os.path.exists(self.paths.exclude_file):\n            with open(self.paths.exclude_file, \"w\", encoding=\"utf-8\") as f:\n                f.write(\"\\n\".join(sorted(self.exclusions.defaults)))\n\n    def load_exclusions(self) -> None:\n        self.exclusions.custom.clear()\n        if os.path.exists(self.paths.exclude_file):\n            with open(self.paths.exclude_file, \"r\", encoding=\"utf-8\") as f:\n                for line in f:\n                    line = line.strip()\n                    if line:\n                        self.exclusions.custom.add(line)\n\n    # ---------- Scan / snapshot ----------\n\n    def scan_project(self) -> ProjectSnapshot:\n        self.load_exclusions()\n        organisation: Dict[str, Dict[str, List[str]]] = {}\n        files_content: Dict[str, str] = {}\n\n        for current_root, dirs, files in os.walk(self.paths.root):\n            rel_root = os.path.relpath(current_root, self.paths.root)\n            if rel_root == \".\":\n                rel_root = \"\"\n\n            dirs[:] = [d for d in dirs if not self.exclusions.should_exclude(d)]\n\n            organisation[rel_root] = {\n                \"dirs\": dirs.copy(),\n                \"files\": [f for f in files if not self.exclusions.should_exclude(f)],\n            }\n\n            for f in files:\n                if self.exclusions.should_exclude(f):\n                    continue\n                rel_path = os.path.join(rel_root, f) if rel_root else f\n                file_path = os.path.join(current_root, f)\n                try:\n                    with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as fp:\n                        files_content[rel_path] = fp.read()\n                except Exception:\n                    files_content[rel_path] = \"<< Impossible de lire ce fichier >>\"\n\n        version = get_next_version_number(self.paths.code_source)\n        return ProjectSnapshot(version=version, organisation=organisation, files_content=files_content)\n\n    # ---------- Sauvegarde / chargement snapshot ----------\n\n    def save_snapshot(self, snapshot: ProjectSnapshot) -> None:\n        save_json(self.paths.organisation_json(snapshot.version), snapshot.organisation)\n        save_json(self.paths.files_content_json(snapshot.version), snapshot.files_content)\n\n    def load_snapshot(self, version: str) -> ProjectSnapshot:\n        org = load_json(self.paths.organisation_json(version))\n        fc = load_json(self.paths.files_content_json(version))\n        return ProjectSnapshot(version=version, organisation=org, files_content=fc)\n\n    # ---------- Exports ----------\n\n    def export_full_context(self, snapshot: ProjectSnapshot) -> None:\n        md = generate_markdown(snapshot)\n        html = generate_html(snapshot)\n        with open(self.paths.context_md, \"w\", encoding=\"utf-8\") as f:\n            f.write(md)\n        with open(self.paths.context_html, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n\n    def export_selected_context(self, snapshot: ProjectSnapshot, selected_files: List[str]) -> None:\n        from data.utils import filter_snapshot\n        filtered = filter_snapshot(snapshot, selected_files)\n        md = generate_markdown(filtered)\n        html = generate_html(filtered)\n        with open(self.paths.selected_context_md, \"w\", encoding=\"utf-8\") as f:\n            f.write(md)\n        with open(self.paths.selected_context_html, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n\n    # ---------- Versioning ----------\n\n    def list_versions(self) -> List[str]:\n        return list_existing_versions(self.paths.code_source)\n\n    def delete_version(self, version: str) -> None:\n        delete_version_files(self.paths.code_source, version)\n\n    # ---------- Restauration ----------\n\n    def restore_all(self, snapshot: ProjectSnapshot) -> None:\n        for rel_path, content in snapshot.files_content.items():\n            abs_path = os.path.join(self.paths.root, rel_path)\n            os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n            with open(abs_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n    def restore_selected(self, snapshot: ProjectSnapshot, selected_files: List[str]) -> None:\n        selected_set = set(selected_files)\n        for rel_path, content in snapshot.files_content.items():\n            if rel_path not in selected_set:\n                continue\n            abs_path = os.path.join(self.paths.root, rel_path)\n            os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n            with open(abs_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)",
    "src\\__init__.py": ""
}