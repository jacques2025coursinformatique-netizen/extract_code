{
    "extract_code.spec": "# -*- mode: python ; coding: utf-8 -*-\n\n\na = Analysis(\n    ['main.py'],\n    pathex=[],\n    binaries=[],\n    datas=[],\n    hiddenimports=[],\n    hookspath=[],\n    hooksconfig={},\n    runtime_hooks=[],\n    excludes=[],\n    noarchive=False,\n    optimize=0,\n)\npyz = PYZ(a.pure)\n\nexe = EXE(\n    pyz,\n    a.scripts,\n    a.binaries,\n    a.datas,\n    [],\n    name='extract_code',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    upx_exclude=[],\n    runtime_tmpdir=None,\n    console=False,\n    disable_windowed_traceback=False,\n    argv_emulation=False,\n    target_arch=None,\n    codesign_identity=None,\n    entitlements_file=None,\n)\n",
    "main.py": "from tkinter import Tk\nfrom interface.ui import ApplicationUI\n\n\ndef main():\n    root = Tk()\n    app = ApplicationUI(root)\n    root.mainloop()\n\n\nif __name__ == \"__main__\":\n    main()",
    "requirements.txt": "tk\npyinstaller",
    "data\\categories.json": "{\n    \"categories\": [\n        \"Essai\"\n    ]\n}",
    "data\\models.py": "import os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Set, Optional\n\n\nDEFAULT_EXCLUDES = [\"venv\", \"code_source\", \"archive\", \".env\",\".venv\",\".git\",\"__pycache__\",\".python-version\",\"dist\",\"build\",\"main.spec\"]\n\n\n@dataclass\nclass ProjectPaths:\n    root: str\n\n    @property\n    def code_source(self) -> str:\n        return os.path.join(self.root, \"code_source\")\n\n    @property\n    def exclude_file(self) -> str:\n        return os.path.join(self.code_source, \"exclude.txt\")\n\n    def organisation_json(self, version: str) -> str:\n        return os.path.join(self.code_source, f\"organisation.{version}.json\")\n\n    def files_content_json(self, version: str) -> str:\n        return os.path.join(self.code_source, f\"files_content.{version}.json\")\n\n    @property\n    def context_md(self) -> str:\n        return os.path.join(self.code_source, \"context.md\")\n\n    @property\n    def context_html(self) -> str:\n        return os.path.join(self.code_source, \"context.html\")\n\n    @property\n    def selected_context_md(self) -> str:\n        return os.path.join(self.code_source, \"selected_context.md\")\n\n    @property\n    def selected_context_html(self) -> str:\n        return os.path.join(self.code_source, \"selected_context.html\")\n\n\n@dataclass\nclass FileEntry:\n    relative_path: str\n    content: str\n\n\n@dataclass\nclass ProjectSnapshot:\n    version: str\n    organisation: Dict[str, Dict[str, List[str]]]\n    files_content: Dict[str, str]\n\n\n@dataclass\nclass ExclusionRules:\n    defaults: Set[str] = field(default_factory=lambda: set(DEFAULT_EXCLUDES))\n    custom: Set[str] = field(default_factory=set)\n\n    def all(self) -> Set[str]:\n        return self.defaults.union(self.custom)\n\n    def should_exclude(self, name: str) -> bool:\n        for ex in self.all():\n            if name == ex or name.startswith(ex):\n                return True\n        return False\n",
    "data\\queries.json": "{\n    \"queries\": [\n        {\n            \"name\": \"Essai\",\n            \"description\": \"Description\",\n            \"category\": \"Essai\",\n            \"context_files\": \"@config @database\",\n            \"versions\": [\n                {\n                    \"version\": \"001\",\n                    \"before\": \"Partie \\tamont\",\n                    \"after\": \"Partie aval\"\n                },\n                {\n                    \"version\": \"002\",\n                    \"before\": \"Partie \\tamont\",\n                    \"after\": \"Partie aval2\"\n                }\n            ]\n        }\n    ]\n}",
    "data\\queries_manager.py": "import json\nimport os\nfrom typing import List, Dict, Optional\n\n\nclass QueriesManager:\n    def __init__(self, base_path: Optional[str] = None):\n        if base_path is None:\n            base_path = os.path.dirname(os.path.abspath(__file__))\n\n        self.base_path = base_path\n        self.queries_path = os.path.join(self.base_path, \"queries.json\")\n        self.categories_path = os.path.join(self.base_path, \"categories.json\")\n\n        self._ensure_files_exist()\n\n        self.queries_data = self.load_queries()\n        self.categories_data = self.load_categories()\n\n    # ---------- Fichiers JSON ----------\n\n    def _ensure_files_exist(self) -> None:\n        if not os.path.exists(self.categories_path):\n            with open(self.categories_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump({\"categories\": []}, f, indent=4, ensure_ascii=False)\n\n        if not os.path.exists(self.queries_path):\n            with open(self.queries_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump({\"queries\": []}, f, indent=4, ensure_ascii=False)\n\n    def load_queries(self) -> Dict:\n        with open(self.queries_path, \"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n\n    def save_queries(self) -> None:\n        with open(self.queries_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.queries_data, f, indent=4, ensure_ascii=False)\n\n    def load_categories(self) -> Dict:\n        with open(self.categories_path, \"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n\n    def save_categories(self) -> None:\n        with open(self.categories_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.categories_data, f, indent=4, ensure_ascii=False)\n\n    # ---------- Catégories ----------\n\n    @property\n    def categories(self) -> List[str]:\n        return self.categories_data.get(\"categories\", [])\n\n    def add_category(self, name: str) -> None:\n        if name and name not in self.categories:\n            self.categories_data[\"categories\"].append(name)\n            self.save_categories()\n\n    def rename_category(self, old: str, new: str) -> None:\n        if old in self.categories and new and new not in self.categories:\n            idx = self.categories.index(old)\n            self.categories_data[\"categories\"][idx] = new\n            # mettre à jour les requêtes qui utilisent cette catégorie\n            for q in self.queries_data.get(\"queries\", []):\n                if q.get(\"category\") == old:\n                    q[\"category\"] = new\n            self.save_categories()\n            self.save_queries()\n\n    def delete_category(self, name: str) -> bool:\n        # retourne False si utilisée par une requête\n        for q in self.queries_data.get(\"queries\", []):\n            if q.get(\"category\") == name:\n                return False\n        if name in self.categories:\n            self.categories_data[\"categories\"].remove(name)\n            self.save_categories()\n        return True\n\n    # ---------- Requêtes ----------\n\n    @property\n    def queries(self) -> List[Dict]:\n        return self.queries_data.get(\"queries\", [])\n\n    def get_query(self, name: str) -> Optional[Dict]:\n        for q in self.queries:\n            if q.get(\"name\") == name:\n                return q\n        return None\n\n    def add_query(\n        self,\n        name: str,\n        description: str,\n        category: str,\n        context_files: str,\n    ) -> None:\n        if not name:\n            return\n        if self.get_query(name) is not None:\n            return\n\n        new_query = {\n            \"name\": name,\n            \"description\": description,\n            \"category\": category,\n            \"context_files\": context_files,\n            \"versions\": [],\n        }\n        self.queries_data[\"queries\"].append(new_query)\n        self.save_queries()\n\n    def update_query(\n        self,\n        name: str,\n        description: str,\n        category: str,\n        context_files: str,\n    ) -> None:\n        q = self.get_query(name)\n        if q is None:\n            return\n        q[\"description\"] = description\n        q[\"category\"] = category\n        q[\"context_files\"] = context_files\n        self.save_queries()\n\n    def delete_query(self, name: str) -> None:\n        self.queries_data[\"queries\"] = [\n            q for q in self.queries if q.get(\"name\") != name\n        ]\n        self.save_queries()\n\n    # ---------- Versions ----------\n\n    def _get_next_version_number(self, query: Dict) -> str:\n        versions = query.get(\"versions\", [])\n        if not versions:\n            return \"001\"\n        last = max(v.get(\"version\", \"000\") for v in versions)\n        try:\n            num = int(last)\n        except ValueError:\n            num = 0\n        return f\"{num + 1:03d}\"\n\n    def add_version(self, query_name: str, before: str, after: str) -> None:\n        q = self.get_query(query_name)\n        if q is None:\n            return\n        version_number = self._get_next_version_number(q)\n        new_version = {\n            \"version\": version_number,\n            \"before\": before,\n            \"after\": after,\n        }\n        q.setdefault(\"versions\", []).append(new_version)\n        self.save_queries()\n\n    def get_version(self, query_name: str, version_number: str) -> Optional[Dict]:\n        q = self.get_query(query_name)\n        if q is None:\n            return None\n        for v in q.get(\"versions\", []):\n            if v.get(\"version\") == version_number:\n                return v\n        return None\n\n    def update_version(\n        self,\n        query_name: str,\n        version_number: str,\n        before: str,\n        after: str,\n    ) -> None:\n        v = self.get_version(query_name, version_number)\n        if v is None:\n            return\n        v[\"before\"] = before\n        v[\"after\"] = after\n        self.save_queries()\n\n    def delete_version(self, query_name: str, version_number: str) -> None:\n        q = self.get_query(query_name)\n        if q is None:\n            return\n        q[\"versions\"] = [\n            v for v in q.get(\"versions\", []) if v.get(\"version\") != version_number\n        ]\n        self.save_queries()",
    "data\\utils.py": "import os\nimport json\nfrom typing import Dict, List, Tuple\nfrom .models import ProjectSnapshot\n\n\ndef load_json(path: str) -> Dict:\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n\n\ndef save_json(path: str, data: Dict) -> None:\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=4, ensure_ascii=False)\n\n\ndef list_existing_versions(code_source_dir: str) -> List[str]:\n    if not os.path.isdir(code_source_dir):\n        return []\n    versions = set()\n    for name in os.listdir(code_source_dir):\n        if name.startswith(\"organisation.\") and name.endswith(\".json\"):\n            middle = name[len(\"organisation.\"):-len(\".json\")]\n            versions.add(middle)\n    return sorted(versions)\n\n\ndef get_next_version_number(code_source_dir: str) -> str:\n    versions = list_existing_versions(code_source_dir)\n    if not versions:\n        return \"001\"\n    last = max(int(v) for v in versions)\n    return f\"{last + 1:03d}\"\n\n\ndef delete_version_files(code_source_dir: str, version: str) -> None:\n    org = os.path.join(code_source_dir, f\"organisation.{version}.json\")\n    fc = os.path.join(code_source_dir, f\"files_content.{version}.json\")\n    for path in (org, fc):\n        if os.path.exists(path):\n            os.remove(path)\n\n\ndef generate_markdown(snapshot: ProjectSnapshot) -> str:\n    md = \"# Organisation du projet\\n\\n\"\n    for folder, content in snapshot.organisation.items():\n        md += f\"## {folder}\\n\"\n        md += \"**Dossiers :**\\n\"\n        for d in content.get(\"dirs\", []):\n            md += f\"- {d}\\n\"\n        md += \"\\n**Fichiers :**\\n\"\n        for f in content.get(\"files\", []):\n            md += f\"- {f}\\n\"\n        md += \"\\n---\\n\"\n\n    md += \"\\n# Contenu des fichiers\\n\\n\"\n    for filepath, text in snapshot.files_content.items():\n        md += f\"## {filepath}\\n\\n\"\n        md += \"```text\\n\"\n        md += text\n        md += \"\\n```\\n\\n\"\n    return md\n\n\ndef generate_html(snapshot: ProjectSnapshot) -> str:\n    html = [\n        \"<html>\",\n        \"<head><meta charset='utf-8'><title>Context</title></head>\",\n        \"<body>\",\n        \"<h1>Organisation du projet</h1>\",\n    ]\n    for folder, content in snapshot.organisation.items():\n        html.append(f\"<h2>{folder}</h2>\")\n        html.append(\"<h3>Dossiers :</h3><ul>\")\n        for d in content.get(\"dirs\", []):\n            html.append(f\"<li>{d}</li>\")\n        html.append(\"</ul>\")\n        html.append(\"<h3>Fichiers :</h3><ul>\")\n        for f in content.get(\"files\", []):\n            html.append(f\"<li>{f}</li>\")\n        html.append(\"</ul><hr>\")\n\n    html.append(\"<h1>Contenu des fichiers</h1>\")\n    for filepath, text in snapshot.files_content.items():\n        html.append(f\"<h2>{filepath}</h2>\")\n        html.append(\"<pre>\")\n        html.append(escape_html(text))\n        html.append(\"</pre>\")\n    html.append(\"</body></html>\")\n    return \"\\n\".join(html)\n\n\ndef escape_html(text: str) -> str:\n    return (\n        text.replace(\"&\", \"&amp;\")\n        .replace(\"<\", \"&lt;\")\n        .replace(\">\", \"&gt;\")\n    )\n\n\ndef filter_snapshot(snapshot: ProjectSnapshot, selected_files: List[str]) -> ProjectSnapshot:\n    selected_set = set(selected_files)\n    filtered_files = {\n        path: content\n        for path, content in snapshot.files_content.items()\n        if path in selected_set\n    }\n\n    filtered_org: Dict[str, Dict[str, List[str]]] = {}\n    for folder, content in snapshot.organisation.items():\n        files = [f for f in content.get(\"files\", []) if os.path.join(folder, f) in selected_set]\n        if files:\n            filtered_org[folder] = {\n                \"dirs\": content.get(\"dirs\", []),\n                \"files\": files,\n            }\n\n    return ProjectSnapshot(\n        version=snapshot.version,\n        organisation=filtered_org,\n        files_content=filtered_files,\n    )\n",
    "data\\__init__.py": "",
    "interface\\ui.py": "import os\nfrom tkinter import (\n    Tk,\n    Frame,\n    Label,\n    Listbox,\n    Scrollbar,\n    SINGLE,\n    MULTIPLE,\n    END,\n    filedialog,\n    messagebox,\n    RIGHT,\n    LEFT,\n    Y,\n    BOTH,\n    Text,\n)\nfrom tkinter import ttk\n\nfrom src.client_logic import ClientLogic\n\nfrom data.queries_manager import QueriesManager\nfrom src.queries_logic import QueriesLogic\nfrom interface.ui_queries import QueriesUI\n\n\nclass ApplicationUI:\n    def __init__(self, root: Tk):\n        self.root = root\n        self.root.title(\"Gestion de contexte projet\")\n\n        # --- Thème moderne ---\n        style = ttk.Style()\n        style.theme_use(\"clam\")\n\n        self.client = ClientLogic()\n\n        # Manager / logique pour les requêtes type\n        self._init_queries_module()\n\n        # Widgets principaux\n        self.preview_text = None\n        self.list_versions = None\n        self.list_files = None\n\n        self._build_layout()\n\n    # -------------------------------------------------------------------------\n    #  INITIALISATION MODULE REQUÊTES TYPE\n    # -------------------------------------------------------------------------\n    def _init_queries_module(self):\n        self.queries_manager = QueriesManager()\n\n        def copy_to_clipboard(text: str):\n            self.root.clipboard_clear()\n            self.root.clipboard_append(text)\n\n        def get_selected_files():\n            return self.get_selected_files()\n\n        self.queries_logic = QueriesLogic(\n            manager=self.queries_manager,\n            copy_to_clipboard=copy_to_clipboard,\n            get_selected_files=get_selected_files,\n        )\n\n        self.queries_ui = None  # sera créé dans le layout\n\n    # -------------------------------------------------------------------------\n    #  LAYOUT GLOBAL : PANEDWINDOW + NOTEBOOK + COLONNE DROITE\n    # -------------------------------------------------------------------------\n    def _build_layout(self):\n        # PanedWindow horizontal : gauche = Notebook, droite = fichiers/preview\n        paned = ttk.PanedWindow(self.root, orient=\"horizontal\")\n        paned.pack(fill=\"both\", expand=True)\n\n        # Frame gauche : Notebook\n        frame_left = Frame(paned)\n        paned.add(frame_left, weight=1)\n\n        # Frame droite : fichiers + preview\n        frame_right = Frame(paned)\n        paned.add(frame_right, weight=2)\n\n        # ---------------------------------------------------------------------\n        # NOTEBOOK À GAUCHE : Onglet Projet + Onglet Requêtes type\n        # ---------------------------------------------------------------------\n        self.notebook = ttk.Notebook(frame_left)\n        self.notebook.pack(fill=\"both\", expand=True, padx=10, pady=10)\n\n        # Onglet Projet\n        self.tab_project = Frame(self.notebook)\n        self.notebook.add(self.tab_project, text=\"Projet\")\n\n        # Onglet Requêtes type\n        self.tab_queries = Frame(self.notebook)\n        self.notebook.add(self.tab_queries, text=\"Requêtes type\")\n\n        # Construire le contenu de l’onglet Projet\n        self._build_project_tab(self.tab_project)\n\n        # Construire le contenu de l’onglet Requêtes type\n        self._build_queries_tab(self.tab_queries)\n\n        # ---------------------------------------------------------------------\n        # COLONNE DROITE : Fichiers + Prévisualisation + Actions\n        # ---------------------------------------------------------------------\n        self._build_right_column(frame_right)\n\n    # -------------------------------------------------------------------------\n    #  ONGLET PROJET\n    # -------------------------------------------------------------------------\n    def _build_project_tab(self, parent: Frame):\n        Label(parent, text=\"Projet\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n        ttk.Button(parent, text=\"Sélectionner un dossier\", command=self.on_select_project).pack(pady=5)\n        ttk.Button(parent, text=\"Ouvrir le dossier sélectionné\", command=self.on_open_folder).pack(pady=5)\n\n        Label(parent, text=\"Extraction complète\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n        ttk.Button(parent, text=\"Extraire l'ensemble du projet\", command=self.on_extract_full).pack(pady=5)\n\n        Label(parent, text=\"Versions disponibles\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_versions = Frame(parent)\n        frame_versions.pack(fill=\"both\", expand=True)\n\n        self.list_versions = Listbox(frame_versions, selectmode=SINGLE, height=10)\n        self.list_versions.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_versions = Scrollbar(frame_versions, orient=\"vertical\", command=self.list_versions.yview)\n        scroll_versions.pack(side=RIGHT, fill=Y)\n\n        self.list_versions.config(yscrollcommand=scroll_versions.set)\n        self.list_versions.bind(\"<<ListboxSelect>>\", self.on_select_version)\n\n        ttk.Button(parent, text=\"Restaurer la version sélectionnée\", command=self.on_restore_full).pack(pady=5)\n        ttk.Button(parent, text=\"Supprimer la version sélectionnée\", command=self.on_delete_version).pack(pady=5)\n\n    # -------------------------------------------------------------------------\n    #  ONGLET REQUÊTES TYPE\n    # -------------------------------------------------------------------------\n    def _build_queries_tab(self, parent: Frame):\n        # On insère directement QueriesUI dans cet onglet\n        self.queries_ui = QueriesUI(\n            parent,\n            manager=self.queries_manager,\n            logic=self.queries_logic,\n        )\n        self.queries_ui.pack(fill=\"both\", expand=True, padx=5, pady=5)\n\n    # -------------------------------------------------------------------------\n    #  COLONNE DROITE : FICHIERS + PRÉVISUALISATION + ACTIONS\n    # -------------------------------------------------------------------------\n    def _build_right_column(self, parent: Frame):\n        Label(parent, text=\"Fichiers de la version sélectionnée\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_files = Frame(parent)\n        frame_files.pack(fill=\"both\", expand=False, padx=10, pady=5)\n\n        self.list_files = Listbox(frame_files, selectmode=MULTIPLE, height=12)\n        self.list_files.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_files = Scrollbar(frame_files, orient=\"vertical\", command=self.list_files.yview)\n        scroll_files.pack(side=RIGHT, fill=Y)\n\n        self.list_files.config(yscrollcommand=scroll_files.set)\n        self.list_files.bind(\"<<ListboxSelect>>\", self.on_file_selected)\n\n        Label(parent, text=\"Prévisualisation du fichier\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_preview = Frame(parent)\n        frame_preview.pack(fill=\"both\", expand=True, padx=10, pady=5)\n\n        self.preview_text = Text(frame_preview, wrap=\"word\", height=20)\n        self.preview_text.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_preview = Scrollbar(frame_preview, orient=\"vertical\", command=self.preview_text.yview)\n        scroll_preview.pack(side=RIGHT, fill=Y)\n\n        self.preview_text.config(yscrollcommand=scroll_preview.set)\n\n        ttk.Button(parent, text=\"Créer selected_context.md & .html\", command=self.on_export_selected).pack(pady=5)\n        ttk.Button(parent, text=\"Restaurer les fichiers sélectionnés\", command=self.on_restore_selected).pack(pady=5)\n\n    # -------------------------------------------------------------------------\n    #  ACTIONS ONGLET PROJET\n    # -------------------------------------------------------------------------\n    def on_select_project(self):\n        folder = filedialog.askdirectory()\n        if not folder:\n            return\n        self.client.select_project(folder)\n        messagebox.showinfo(\"Projet sélectionné\", f\"Dossier : {folder}\")\n        self.refresh_versions()\n\n    def on_open_folder(self):\n        try:\n            self.client.open_project_folder()\n        except Exception as e:\n            messagebox.showerror(\"Erreur\", str(e))\n\n    def on_extract_full(self):\n        if not self.client.has_project():\n            messagebox.showerror(\"Erreur\", \"Aucun projet sélectionné.\")\n            return\n        version = self.client.extract_full_project()\n        messagebox.showinfo(\"Extraction terminée\", f\"Version créée : {version}\")\n        self.refresh_versions()\n        self.select_version_in_list(version)\n\n    def refresh_versions(self):\n        if self.list_versions is None:\n            return\n        self.list_versions.delete(0, END)\n        versions = self.client.get_available_versions()\n        for v in versions:\n            self.list_versions.insert(END, v)\n\n    def on_select_version(self, event=None):\n        selection = self.list_versions.curselection()\n        if not selection:\n            return\n        index = selection[0]\n        version = self.list_versions.get(index)\n        self.client.select_version(version)\n        self.refresh_files()\n\n    def on_restore_full(self):\n        try:\n            self.client.restore_full_version()\n            messagebox.showinfo(\"Restauration\", \"Restauration complète effectuée.\")\n        except Exception as e:\n            messagebox.showerror(\"Erreur\", str(e))\n\n    def on_delete_version(self):\n        self.client.delete_selected_version()\n        self.refresh_versions()\n        if self.list_files is not None:\n            self.list_files.delete(0, END)\n        if self.preview_text is not None:\n            self.preview_text.delete(1.0, END)\n\n    # -------------------------------------------------------------------------\n    #  ACTIONS COLONNE DROITE\n    # -------------------------------------------------------------------------\n    def refresh_files(self):\n        if self.list_files is None:\n            return\n        self.list_files.delete(0, END)\n        files = self.client.get_files_from_selected_version()\n        for f in files:\n            self.list_files.insert(END, f)\n        if self.preview_text is not None:\n            self.preview_text.delete(1.0, END)\n\n    def on_file_selected(self, event=None):\n        selection = self.list_files.curselection()\n        if not selection:\n            self.preview_text.delete(1.0, END)\n            return\n\n        index = selection[0]\n        filename = self.list_files.get(index)\n\n        snapshot = self.client.server.load_snapshot(self.client.selected_version)\n        content = snapshot.files_content.get(filename, \"\")\n\n        self.preview_text.delete(1.0, END)\n        self.preview_text.insert(END, content)\n\n    def on_export_selected(self):\n        selected_indices = self.list_files.curselection()\n        files = [self.list_files.get(i) for i in selected_indices]\n        self.client.set_selected_files(files)\n        self.client.export_selected_markdown_and_html()\n        messagebox.showinfo(\"Export\", \"selected_context.md et selected_context.html générés.\")\n\n    def on_restore_selected(self):\n        selected_indices = self.list_files.curselection()\n        files = [self.list_files.get(i) for i in selected_indices]\n        self.client.set_selected_files(files)\n        self.client.restore_selected_files()\n        messagebox.showinfo(\"Restauration\", \"Fichiers sélectionnés restaurés.\")\n\n    # -------------------------------------------------------------------------\n    #  HELPERS\n    # -------------------------------------------------------------------------\n    def get_selected_files(self):\n        \"\"\"\n        Utilisé par QueriesLogic pour récupérer les fichiers sélectionnés\n        dans la colonne droite.\n        \"\"\"\n        if self.list_files is None:\n            return []\n        selected_indices = self.list_files.curselection()\n        return [self.list_files.get(i) for i in selected_indices]\n\n    def select_version_in_list(self, version: str):\n        if self.list_versions is None:\n            return\n        for i in range(self.list_versions.size()):\n            if self.list_versions.get(i) == version:\n                self.list_versions.selection_clear(0, END)\n                self.list_versions.selection_set(i)\n                self.list_versions.activate(i)\n                self.on_select_version()\n                break\n",
    "interface\\ui_queries.py": "import tkinter as tk\nfrom tkinter import ttk, messagebox\n\nfrom data.queries_manager import QueriesManager\nfrom src.queries_logic import QueriesLogic\n\n\nclass QueriesUI(ttk.Frame):\n    def __init__(\n        self,\n        master,\n        manager: QueriesManager,\n        logic: QueriesLogic,\n        **kwargs,\n    ):\n        super().__init__(master, **kwargs)\n        self.manager = manager\n        self.logic = logic\n\n        self.selected_query_name = None\n        self.selected_version_number = None\n\n        self._build_widgets()\n        self._refresh_categories()\n        self._refresh_queries()\n\n    # ---------- Construction UI ----------\n\n    def _build_widgets(self):\n        # colonnes principales\n        self.columnconfigure(0, weight=1)\n        self.columnconfigure(1, weight=2)\n        self.columnconfigure(2, weight=1)\n\n        # --- Colonne catégories ---\n        cat_frame = ttk.LabelFrame(self, text=\"Catégories\")\n        cat_frame.grid(row=0, column=0, sticky=\"nsew\", padx=5, pady=5)\n\n        self.categories_list = tk.Listbox(cat_frame, height=8)\n        self.categories_list.grid(row=0, column=0, columnspan=3, sticky=\"nsew\", padx=2, pady=2)\n        cat_frame.rowconfigure(0, weight=1)\n        cat_frame.columnconfigure(0, weight=1)\n\n        btn_cat_add = ttk.Button(cat_frame, text=\"Ajouter\", command=self._on_add_category)\n        btn_cat_ren = ttk.Button(cat_frame, text=\"Renommer\", command=self._on_rename_category)\n        btn_cat_del = ttk.Button(cat_frame, text=\"Supprimer\", command=self._on_delete_category)\n        btn_cat_add.grid(row=1, column=0, sticky=\"ew\", padx=2, pady=2)\n        btn_cat_ren.grid(row=1, column=1, sticky=\"ew\", padx=2, pady=2)\n        btn_cat_del.grid(row=1, column=2, sticky=\"ew\", padx=2, pady=2)\n\n        # --- Colonne requêtes ---\n        q_frame = ttk.LabelFrame(self, text=\"Requêtes\")\n        q_frame.grid(row=0, column=1, sticky=\"nsew\", padx=5, pady=5)\n        q_frame.rowconfigure(0, weight=1)\n        q_frame.columnconfigure(0, weight=1)\n\n        self.queries_list = tk.Listbox(q_frame, height=8)\n        self.queries_list.grid(row=0, column=0, columnspan=3, sticky=\"nsew\", padx=2, pady=2)\n        self.queries_list.bind(\"<<ListboxSelect>>\", self._on_select_query)\n\n        btn_q_add = ttk.Button(q_frame, text=\"Ajouter\", command=self._on_add_query)\n        btn_q_mod = ttk.Button(q_frame, text=\"Modifier\", command=self._on_edit_query)\n        btn_q_del = ttk.Button(q_frame, text=\"Supprimer\", command=self._on_delete_query)\n        btn_q_add.grid(row=1, column=0, sticky=\"ew\", padx=2, pady=2)\n        btn_q_mod.grid(row=1, column=1, sticky=\"ew\", padx=2, pady=2)\n        btn_q_del.grid(row=1, column=2, sticky=\"ew\", padx=2, pady=2)\n\n        # --- Colonne versions ---\n        v_frame = ttk.LabelFrame(self, text=\"Versions\")\n        v_frame.grid(row=0, column=2, sticky=\"nsew\", padx=5, pady=5)\n        v_frame.rowconfigure(0, weight=1)\n        v_frame.columnconfigure(0, weight=1)\n\n        self.versions_list = tk.Listbox(v_frame, height=8)\n        self.versions_list.grid(row=0, column=0, columnspan=3, sticky=\"nsew\", padx=2, pady=2)\n        self.versions_list.bind(\"<<ListboxSelect>>\", self._on_select_version)\n\n        btn_v_add = ttk.Button(v_frame, text=\"Ajouter\", command=self._on_add_version)\n        btn_v_mod = ttk.Button(v_frame, text=\"Modifier\", command=self._on_edit_version)\n        btn_v_del = ttk.Button(v_frame, text=\"Supprimer\", command=self._on_delete_version)\n        btn_v_add.grid(row=1, column=0, sticky=\"ew\", padx=2, pady=2)\n        btn_v_mod.grid(row=1, column=1, sticky=\"ew\", padx=2, pady=2)\n        btn_v_del.grid(row=1, column=2, sticky=\"ew\", padx=2, pady=2)\n\n        # --- Édition requête ---\n        edit_q_frame = ttk.LabelFrame(self, text=\"Édition de la requête\")\n        edit_q_frame.grid(row=1, column=0, columnspan=3, sticky=\"nsew\", padx=5, pady=5)\n        for c in range(2):\n            edit_q_frame.columnconfigure(c, weight=1)\n\n        ttk.Label(edit_q_frame, text=\"Nom :\").grid(row=0, column=0, sticky=\"w\")\n        self.entry_name = ttk.Entry(edit_q_frame)\n        self.entry_name.grid(row=0, column=1, sticky=\"ew\", padx=2, pady=2)\n\n        ttk.Label(edit_q_frame, text=\"Description :\").grid(row=1, column=0, sticky=\"nw\")\n        self.text_description = tk.Text(edit_q_frame, height=3)\n        self.text_description.grid(row=1, column=1, sticky=\"ew\", padx=2, pady=2)\n\n        ttk.Label(edit_q_frame, text=\"Catégorie :\").grid(row=2, column=0, sticky=\"w\")\n        self.combo_category = ttk.Combobox(edit_q_frame, state=\"readonly\")\n        self.combo_category.grid(row=2, column=1, sticky=\"ew\", padx=2, pady=2)\n\n        ttk.Label(edit_q_frame, text=\"Context files (texte) :\").grid(row=3, column=0, sticky=\"nw\")\n        self.text_context_files = tk.Text(edit_q_frame, height=2)\n        self.text_context_files.grid(row=3, column=1, sticky=\"ew\", padx=2, pady=2)\n\n        # --- Édition version ---\n        edit_v_frame = ttk.LabelFrame(self, text=\"Édition de la version\")\n        edit_v_frame.grid(row=2, column=0, columnspan=3, sticky=\"nsew\", padx=5, pady=5)\n        edit_v_frame.columnconfigure(0, weight=1)\n        edit_v_frame.columnconfigure(1, weight=1)\n\n        ttk.Label(edit_v_frame, text=\"Partie amont :\").grid(row=0, column=0, sticky=\"nw\")\n        self.text_before = tk.Text(edit_v_frame, height=5)\n        self.text_before.grid(row=1, column=0, sticky=\"nsew\", padx=2, pady=2)\n\n        ttk.Label(edit_v_frame, text=\"Partie aval :\").grid(row=0, column=1, sticky=\"nw\")\n        self.text_after = tk.Text(edit_v_frame, height=5)\n        self.text_after.grid(row=1, column=1, sticky=\"nsew\", padx=2, pady=2)\n\n        # --- Boutons génération ---\n        btn_frame = ttk.Frame(self)\n        btn_frame.grid(row=3, column=0, columnspan=3, sticky=\"ew\", padx=5, pady=5)\n        btn_frame.columnconfigure(0, weight=1)\n        btn_frame.columnconfigure(1, weight=1)\n\n        btn_edge = ttk.Button(btn_frame, text=\"Générer Edge Copilot\", command=self._on_generate_edge)\n        btn_gh = ttk.Button(btn_frame, text=\"Générer GitHub Copilot\", command=self._on_generate_github)\n        btn_edge.grid(row=0, column=0, sticky=\"ew\", padx=2, pady=2)\n        btn_gh.grid(row=0, column=1, sticky=\"ew\", padx=2, pady=2)\n\n    # ---------- Helpers UI ----------\n\n    def _refresh_categories(self):\n        self.categories_list.delete(0, tk.END)\n        for cat in self.manager.categories:\n            self.categories_list.insert(tk.END, cat)\n        self.combo_category[\"values\"] = self.manager.categories\n\n    def _refresh_queries(self):\n        self.queries_list.delete(0, tk.END)\n        for q in self.manager.queries:\n            self.queries_list.insert(tk.END, q.get(\"name\", \"\"))\n\n    def _refresh_versions(self):\n        self.versions_list.delete(0, tk.END)\n        if not self.selected_query_name:\n            return\n        q = self.manager.get_query(self.selected_query_name)\n        if not q:\n            return\n        for v in q.get(\"versions\", []):\n            self.versions_list.insert(tk.END, v.get(\"version\", \"\"))\n\n    def _load_query_into_form(self):\n        if not self.selected_query_name:\n            return\n        q = self.manager.get_query(self.selected_query_name)\n        if not q:\n            return\n\n        self.entry_name.delete(0, tk.END)\n        self.entry_name.insert(0, q.get(\"name\", \"\"))\n\n        self.text_description.delete(\"1.0\", tk.END)\n        self.text_description.insert(\"1.0\", q.get(\"description\", \"\"))\n\n        self.combo_category.set(q.get(\"category\", \"\"))\n\n        self.text_context_files.delete(\"1.0\", tk.END)\n        self.text_context_files.insert(\"1.0\", q.get(\"context_files\", \"\"))\n\n    def _load_version_into_form(self):\n        if not self.selected_query_name or not self.selected_version_number:\n            return\n        v = self.manager.get_version(self.selected_query_name, self.selected_version_number)\n        if not v:\n            return\n\n        self.text_before.delete(\"1.0\", tk.END)\n        self.text_before.insert(\"1.0\", v.get(\"before\", \"\"))\n\n        self.text_after.delete(\"1.0\", tk.END)\n        self.text_after.insert(\"1.0\", v.get(\"after\", \"\"))\n\n    # ---------- Callbacks catégories ----------\n\n    def _on_add_category(self):\n        name = self._simple_prompt(\"Nouvelle catégorie\", \"Nom de la catégorie :\")\n        if not name:\n            return\n        self.manager.add_category(name)\n        self._refresh_categories()\n\n    def _on_rename_category(self):\n        sel = self.categories_list.curselection()\n        if not sel:\n            return\n        old = self.categories_list.get(sel[0])\n        new = self._simple_prompt(\"Renommer catégorie\", f\"Nouveau nom pour '{old}' :\")\n        if not new:\n            return\n        self.manager.rename_category(old, new)\n        self._refresh_categories()\n        self._refresh_queries()\n\n    def _on_delete_category(self):\n        sel = self.categories_list.curselection()\n        if not sel:\n            return\n        name = self.categories_list.get(sel[0])\n        ok = self.manager.delete_category(name)\n        if not ok:\n            messagebox.showwarning(\n                \"Suppression impossible\",\n                \"Cette catégorie est utilisée par au moins une requête.\",\n            )\n        self._refresh_categories()\n\n    # ---------- Callbacks requêtes ----------\n\n    def _on_select_query(self, event=None):\n        sel = self.queries_list.curselection()\n        if not sel:\n            self.selected_query_name = None\n            return\n        self.selected_query_name = self.queries_list.get(sel[0])\n        self._load_query_into_form()\n        self._refresh_versions()\n\n    def _on_add_query(self):\n        name = self._simple_prompt(\"Nouvelle requête\", \"Nom de la requête :\")\n        if not name:\n            return\n        self.manager.add_query(\n            name=name,\n            description=\"\",\n            category=self.manager.categories[0] if self.manager.categories else \"\",\n            context_files=\"\",\n        )\n        self._refresh_queries()\n\n    def _on_edit_query(self):\n        if not self.selected_query_name:\n            return\n        name = self.entry_name.get().strip()\n        desc = self.text_description.get(\"1.0\", tk.END).strip()\n        cat = self.combo_category.get().strip()\n        ctx = self.text_context_files.get(\"1.0\", tk.END).strip()\n        if not name:\n            messagebox.showwarning(\"Erreur\", \"Le nom de la requête ne peut pas être vide.\")\n            return\n        # on ne gère pas ici le renommage de la clé 'name' pour rester simple\n        self.manager.update_query(\n            name=self.selected_query_name,\n            description=desc,\n            category=cat,\n            context_files=ctx,\n        )\n        self._refresh_queries()\n\n    def _on_delete_query(self):\n        if not self.selected_query_name:\n            return\n        if not messagebox.askyesno(\"Confirmation\", f\"Supprimer la requête '{self.selected_query_name}' ?\"):\n            return\n        self.manager.delete_query(self.selected_query_name)\n        self.selected_query_name = None\n        self._refresh_queries()\n        self.versions_list.delete(0, tk.END)\n\n    # ---------- Callbacks versions ----------\n\n    def _on_select_version(self, event=None):\n        sel = self.versions_list.curselection()\n        if not sel:\n            self.selected_version_number = None\n            return\n        self.selected_version_number = self.versions_list.get(sel[0])\n        self._load_version_into_form()\n\n    def _on_add_version(self):\n        if not self.selected_query_name:\n            messagebox.showwarning(\"Erreur\", \"Sélectionnez d'abord une requête.\")\n            return\n        before = self.text_before.get(\"1.0\", tk.END).strip()\n        after = self.text_after.get(\"1.0\", tk.END).strip()\n        self.manager.add_version(self.selected_query_name, before, after)\n        self._refresh_versions()\n\n    def _on_edit_version(self):\n        if not (self.selected_query_name and self.selected_version_number):\n            return\n        before = self.text_before.get(\"1.0\", tk.END).strip()\n        after = self.text_after.get(\"1.0\", tk.END).strip()\n        self.manager.update_version(\n            self.selected_query_name,\n            self.selected_version_number,\n            before,\n            after,\n        )\n        self._refresh_versions()\n\n    def _on_delete_version(self):\n        if not (self.selected_query_name and self.selected_version_number):\n            return\n        if not messagebox.askyesno(\n            \"Confirmation\",\n            f\"Supprimer la version {self.selected_version_number} ?\",\n        ):\n            return\n        self.manager.delete_version(self.selected_query_name, self.selected_version_number)\n        self.selected_version_number = None\n        self._refresh_versions()\n        self.text_before.delete(\"1.0\", tk.END)\n        self.text_after.delete(\"1.0\", tk.END)\n\n    # ---------- Génération ----------\n\n    def _on_generate_edge(self):\n        if not (self.selected_query_name and self.selected_version_number):\n            messagebox.showwarning(\"Erreur\", \"Sélectionnez une requête et une version.\")\n            return\n        text = self.logic.generate_edge_copilot(\n            self.selected_query_name,\n            self.selected_version_number,\n        )\n        if text:\n            self._show_result_window(\"Edge Copilot\", text)\n\n    def _on_generate_github(self):\n        if not (self.selected_query_name and self.selected_version_number):\n            messagebox.showwarning(\"Erreur\", \"Sélectionnez une requête et une version.\")\n            return\n        text = self.logic.generate_github_copilot(\n            self.selected_query_name,\n            self.selected_version_number,\n        )\n        if text:\n            self._show_result_window(\"GitHub Copilot\", text)\n\n    # ---------- Utilitaires ----------\n\n    def _simple_prompt(self, title: str, label: str) -> str:\n        dialog = tk.Toplevel(self)\n        dialog.title(title)\n        dialog.transient(self.winfo_toplevel())\n        dialog.grab_set()\n\n        ttk.Label(dialog, text=label).grid(row=0, column=0, padx=5, pady=5)\n        entry = ttk.Entry(dialog)\n        entry.grid(row=1, column=0, padx=5, pady=5)\n        entry.focus_set()\n\n        result = {\"value\": None}\n\n        def on_ok():\n            result[\"value\"] = entry.get().strip()\n            dialog.destroy()\n\n        def on_cancel():\n            dialog.destroy()\n\n        btn_frame = ttk.Frame(dialog)\n        btn_frame.grid(row=2, column=0, pady=5)\n        ttk.Button(btn_frame, text=\"OK\", command=on_ok).grid(row=0, column=0, padx=5)\n        ttk.Button(btn_frame, text=\"Annuler\", command=on_cancel).grid(row=0, column=1, padx=5)\n\n        dialog.wait_window()\n        return result[\"value\"]\n\n    def _show_result_window(self, title: str, text: str):\n        win = tk.Toplevel(self)\n        win.title(title)\n        win.geometry(\"800x600\")\n        txt = tk.Text(win, wrap=\"word\")\n        txt.pack(fill=\"both\", expand=True)\n        txt.insert(\"1.0\", text)\n        txt.config(state=\"disabled\")\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\n\nfrom data.queries_manager import QueriesManager\nfrom src.queries_logic import QueriesLogic\n\n\nclass QueriesUI(ttk.Frame):\n    def __init__(\n        self,\n        master,\n        manager: QueriesManager,\n        logic: QueriesLogic,\n        **kwargs,\n    ):\n        super().__init__(master, **kwargs)\n        self.manager = manager\n        self.logic = logic\n\n        self.selected_query_name = None\n        self.selected_version_number = None\n\n        self._build_widgets()\n        self._refresh_categories()\n        self._refresh_queries()\n\n    # ---------- Construction UI ----------\n\n    def _build_widgets(self):\n        # colonnes principales\n        self.columnconfigure(0, weight=1)\n        self.columnconfigure(1, weight=2)\n        self.columnconfigure(2, weight=1)\n\n        # --- Colonne catégories ---\n        cat_frame = ttk.LabelFrame(self, text=\"Catégories\")\n        cat_frame.grid(row=0, column=0, sticky=\"nsew\", padx=5, pady=5)\n\n        self.categories_list = tk.Listbox(cat_frame, height=8)\n        self.categories_list.grid(row=0, column=0, columnspan=3, sticky=\"nsew\", padx=2, pady=2)\n        cat_frame.rowconfigure(0, weight=1)\n        cat_frame.columnconfigure(0, weight=1)\n\n        btn_cat_add = ttk.Button(cat_frame, text=\"Ajouter\", command=self._on_add_category)\n        btn_cat_ren = ttk.Button(cat_frame, text=\"Renommer\", command=self._on_rename_category)\n        btn_cat_del = ttk.Button(cat_frame, text=\"Supprimer\", command=self._on_delete_category)\n        btn_cat_add.grid(row=1, column=0, sticky=\"ew\", padx=2, pady=2)\n        btn_cat_ren.grid(row=1, column=1, sticky=\"ew\", padx=2, pady=2)\n        btn_cat_del.grid(row=1, column=2, sticky=\"ew\", padx=2, pady=2)\n\n        # --- Colonne requêtes ---\n        q_frame = ttk.LabelFrame(self, text=\"Requêtes\")\n        q_frame.grid(row=0, column=1, sticky=\"nsew\", padx=5, pady=5)\n        q_frame.rowconfigure(0, weight=1)\n        q_frame.columnconfigure(0, weight=1)\n\n        self.queries_list = tk.Listbox(q_frame, height=8)\n        self.queries_list.grid(row=0, column=0, columnspan=3, sticky=\"nsew\", padx=2, pady=2)\n        self.queries_list.bind(\"<<ListboxSelect>>\", self._on_select_query)\n\n        btn_q_add = ttk.Button(q_frame, text=\"Ajouter\", command=self._on_add_query)\n        btn_q_mod = ttk.Button(q_frame, text=\"Modifier\", command=self._on_edit_query)\n        btn_q_del = ttk.Button(q_frame, text=\"Supprimer\", command=self._on_delete_query)\n        btn_q_add.grid(row=1, column=0, sticky=\"ew\", padx=2, pady=2)\n        btn_q_mod.grid(row=1, column=1, sticky=\"ew\", padx=2, pady=2)\n        btn_q_del.grid(row=1, column=2, sticky=\"ew\", padx=2, pady=2)\n\n        # --- Colonne versions ---\n        v_frame = ttk.LabelFrame(self, text=\"Versions\")\n        v_frame.grid(row=0, column=2, sticky=\"nsew\", padx=5, pady=5)\n        v_frame.rowconfigure(0, weight=1)\n        v_frame.columnconfigure(0, weight=1)\n\n        self.versions_list = tk.Listbox(v_frame, height=8)\n        self.versions_list.grid(row=0, column=0, columnspan=3, sticky=\"nsew\", padx=2, pady=2)\n        self.versions_list.bind(\"<<ListboxSelect>>\", self._on_select_version)\n\n        btn_v_add = ttk.Button(v_frame, text=\"Ajouter\", command=self._on_add_version)\n        btn_v_mod = ttk.Button(v_frame, text=\"Modifier\", command=self._on_edit_version)\n        btn_v_del = ttk.Button(v_frame, text=\"Supprimer\", command=self._on_delete_version)\n        btn_v_add.grid(row=1, column=0, sticky=\"ew\", padx=2, pady=2)\n        btn_v_mod.grid(row=1, column=1, sticky=\"ew\", padx=2, pady=2)\n        btn_v_del.grid(row=1, column=2, sticky=\"ew\", padx=2, pady=2)\n\n        # --- Édition requête ---\n        edit_q_frame = ttk.LabelFrame(self, text=\"Édition de la requête\")\n        edit_q_frame.grid(row=1, column=0, columnspan=3, sticky=\"nsew\", padx=5, pady=5)\n        for c in range(2):\n            edit_q_frame.columnconfigure(c, weight=1)\n\n        ttk.Label(edit_q_frame, text=\"Nom :\").grid(row=0, column=0, sticky=\"w\")\n        self.entry_name = ttk.Entry(edit_q_frame)\n        self.entry_name.grid(row=0, column=1, sticky=\"ew\", padx=2, pady=2)\n\n        ttk.Label(edit_q_frame, text=\"Description :\").grid(row=1, column=0, sticky=\"nw\")\n        self.text_description = tk.Text(edit_q_frame, height=3)\n        self.text_description.grid(row=1, column=1, sticky=\"ew\", padx=2, pady=2)\n\n        ttk.Label(edit_q_frame, text=\"Catégorie :\").grid(row=2, column=0, sticky=\"w\")\n        self.combo_category = ttk.Combobox(edit_q_frame, state=\"readonly\")\n        self.combo_category.grid(row=2, column=1, sticky=\"ew\", padx=2, pady=2)\n\n        ttk.Label(edit_q_frame, text=\"Context files (texte) :\").grid(row=3, column=0, sticky=\"nw\")\n        self.text_context_files = tk.Text(edit_q_frame, height=2)\n        self.text_context_files.grid(row=3, column=1, sticky=\"ew\", padx=2, pady=2)\n\n        # --- Édition version ---\n        edit_v_frame = ttk.LabelFrame(self, text=\"Édition de la version\")\n        edit_v_frame.grid(row=2, column=0, columnspan=3, sticky=\"nsew\", padx=5, pady=5)\n        edit_v_frame.columnconfigure(0, weight=1)\n        edit_v_frame.columnconfigure(1, weight=1)\n\n        ttk.Label(edit_v_frame, text=\"Partie amont :\").grid(row=0, column=0, sticky=\"nw\")\n        self.text_before = tk.Text(edit_v_frame, height=5)\n        self.text_before.grid(row=1, column=0, sticky=\"nsew\", padx=2, pady=2)\n\n        ttk.Label(edit_v_frame, text=\"Partie aval :\").grid(row=0, column=1, sticky=\"nw\")\n        self.text_after = tk.Text(edit_v_frame, height=5)\n        self.text_after.grid(row=1, column=1, sticky=\"nsew\", padx=2, pady=2)\n\n        # --- Boutons génération ---\n        btn_frame = ttk.Frame(self)\n        btn_frame.grid(row=3, column=0, columnspan=3, sticky=\"ew\", padx=5, pady=5)\n        btn_frame.columnconfigure(0, weight=1)\n        btn_frame.columnconfigure(1, weight=1)\n\n        btn_edge = ttk.Button(btn_frame, text=\"Générer Edge Copilot\", command=self._on_generate_edge)\n        btn_gh = ttk.Button(btn_frame, text=\"Générer GitHub Copilot\", command=self._on_generate_github)\n        btn_edge.grid(row=0, column=0, sticky=\"ew\", padx=2, pady=2)\n        btn_gh.grid(row=0, column=1, sticky=\"ew\", padx=2, pady=2)\n\n    # ---------- Helpers UI ----------\n\n    def _refresh_categories(self):\n        self.categories_list.delete(0, tk.END)\n        for cat in self.manager.categories:\n            self.categories_list.insert(tk.END, cat)\n        self.combo_category[\"values\"] = self.manager.categories\n\n    def _refresh_queries(self):\n        self.queries_list.delete(0, tk.END)\n        for q in self.manager.queries:\n            self.queries_list.insert(tk.END, q.get(\"name\", \"\"))\n\n    def _refresh_versions(self):\n        self.versions_list.delete(0, tk.END)\n        if not self.selected_query_name:\n            return\n        q = self.manager.get_query(self.selected_query_name)\n        if not q:\n            return\n        for v in q.get(\"versions\", []):\n            self.versions_list.insert(tk.END, v.get(\"version\", \"\"))\n\n    def _load_query_into_form(self):\n        if not self.selected_query_name:\n            return\n        q = self.manager.get_query(self.selected_query_name)\n        if not q:\n            return\n\n        self.entry_name.delete(0, tk.END)\n        self.entry_name.insert(0, q.get(\"name\", \"\"))\n\n        self.text_description.delete(\"1.0\", tk.END)\n        self.text_description.insert(\"1.0\", q.get(\"description\", \"\"))\n\n        self.combo_category.set(q.get(\"category\", \"\"))\n\n        self.text_context_files.delete(\"1.0\", tk.END)\n        self.text_context_files.insert(\"1.0\", q.get(\"context_files\", \"\"))\n\n    def _load_version_into_form(self):\n        if not self.selected_query_name or not self.selected_version_number:\n            return\n        v = self.manager.get_version(self.selected_query_name, self.selected_version_number)\n        if not v:\n            return\n\n        self.text_before.delete(\"1.0\", tk.END)\n        self.text_before.insert(\"1.0\", v.get(\"before\", \"\"))\n\n        self.text_after.delete(\"1.0\", tk.END)\n        self.text_after.insert(\"1.0\", v.get(\"after\", \"\"))\n\n    # ---------- Callbacks catégories ----------\n\n    def _on_add_category(self):\n        name = self._simple_prompt(\"Nouvelle catégorie\", \"Nom de la catégorie :\")\n        if not name:\n            return\n        self.manager.add_category(name)\n        self._refresh_categories()\n\n    def _on_rename_category(self):\n        sel = self.categories_list.curselection()\n        if not sel:\n            return\n        old = self.categories_list.get(sel[0])\n        new = self._simple_prompt(\"Renommer catégorie\", f\"Nouveau nom pour '{old}' :\")\n        if not new:\n            return\n        self.manager.rename_category(old, new)\n        self._refresh_categories()\n        self._refresh_queries()\n\n    def _on_delete_category(self):\n        sel = self.categories_list.curselection()\n        if not sel:\n            return\n        name = self.categories_list.get(sel[0])\n        ok = self.manager.delete_category(name)\n        if not ok:\n            messagebox.showwarning(\n                \"Suppression impossible\",\n                \"Cette catégorie est utilisée par au moins une requête.\",\n            )\n        self._refresh_categories()\n\n    # ---------- Callbacks requêtes ----------\n\n    def _on_select_query(self, event=None):\n        sel = self.queries_list.curselection()\n        if not sel:\n            self.selected_query_name = None\n            return\n        self.selected_query_name = self.queries_list.get(sel[0])\n        self._load_query_into_form()\n        self._refresh_versions()\n\n    def _on_add_query(self):\n        name = self._simple_prompt(\"Nouvelle requête\", \"Nom de la requête :\")\n        if not name:\n            return\n        self.manager.add_query(\n            name=name,\n            description=\"\",\n            category=self.manager.categories[0] if self.manager.categories else \"\",\n            context_files=\"\",\n        )\n        self._refresh_queries()\n\n    def _on_edit_query(self):\n        if not self.selected_query_name:\n            return\n        name = self.entry_name.get().strip()\n        desc = self.text_description.get(\"1.0\", tk.END).strip()\n        cat = self.combo_category.get().strip()\n        ctx = self.text_context_files.get(\"1.0\", tk.END).strip()\n        if not name:\n            messagebox.showwarning(\"Erreur\", \"Le nom de la requête ne peut pas être vide.\")\n            return\n        # on ne gère pas ici le renommage de la clé 'name' pour rester simple\n        self.manager.update_query(\n            name=self.selected_query_name,\n            description=desc,\n            category=cat,\n            context_files=ctx,\n        )\n        self._refresh_queries()\n\n    def _on_delete_query(self):\n        if not self.selected_query_name:\n            return\n        if not messagebox.askyesno(\"Confirmation\", f\"Supprimer la requête '{self.selected_query_name}' ?\"):\n            return\n        self.manager.delete_query(self.selected_query_name)\n        self.selected_query_name = None\n        self._refresh_queries()\n        self.versions_list.delete(0, tk.END)\n\n    # ---------- Callbacks versions ----------\n\n    def _on_select_version(self, event=None):\n        sel = self.versions_list.curselection()\n        if not sel:\n            self.selected_version_number = None\n            return\n        self.selected_version_number = self.versions_list.get(sel[0])\n        self._load_version_into_form()\n\n    def _on_add_version(self):\n        if not self.selected_query_name:\n            messagebox.showwarning(\"Erreur\", \"Sélectionnez d'abord une requête.\")\n            return\n        before = self.text_before.get(\"1.0\", tk.END).strip()\n        after = self.text_after.get(\"1.0\", tk.END).strip()\n        self.manager.add_version(self.selected_query_name, before, after)\n        self._refresh_versions()\n\n    def _on_edit_version(self):\n        if not (self.selected_query_name and self.selected_version_number):\n            return\n        before = self.text_before.get(\"1.0\", tk.END).strip()\n        after = self.text_after.get(\"1.0\", tk.END).strip()\n        self.manager.update_version(\n            self.selected_query_name,\n            self.selected_version_number,\n            before,\n            after,\n        )\n        self._refresh_versions()\n\n    def _on_delete_version(self):\n        if not (self.selected_query_name and self.selected_version_number):\n            return\n        if not messagebox.askyesno(\n            \"Confirmation\",\n            f\"Supprimer la version {self.selected_version_number} ?\",\n        ):\n            return\n        self.manager.delete_version(self.selected_query_name, self.selected_version_number)\n        self.selected_version_number = None\n        self._refresh_versions()\n        self.text_before.delete(\"1.0\", tk.END)\n        self.text_after.delete(\"1.0\", tk.END)\n\n    # ---------- Génération ----------\n\n    def _on_generate_edge(self):\n        if not (self.selected_query_name and self.selected_version_number):\n            messagebox.showwarning(\"Erreur\", \"Sélectionnez une requête et une version.\")\n            return\n        text = self.logic.generate_edge_copilot(\n            self.selected_query_name,\n            self.selected_version_number,\n        )\n        if text:\n            self._show_result_window(\"Edge Copilot\", text)\n\n    def _on_generate_github(self):\n        if not (self.selected_query_name and self.selected_version_number):\n            messagebox.showwarning(\"Erreur\", \"Sélectionnez une requête et une version.\")\n            return\n        text = self.logic.generate_github_copilot(\n            self.selected_query_name,\n            self.selected_version_number,\n        )\n        if text:\n            self._show_result_window(\"GitHub Copilot\", text)\n\n    # ---------- Utilitaires ----------\n\n    def _simple_prompt(self, title: str, label: str) -> str:\n        dialog = tk.Toplevel(self)\n        dialog.title(title)\n        dialog.transient(self.winfo_toplevel())\n        dialog.grab_set()\n\n        ttk.Label(dialog, text=label).grid(row=0, column=0, padx=5, pady=5)\n        entry = ttk.Entry(dialog)\n        entry.grid(row=1, column=0, padx=5, pady=5)\n        entry.focus_set()\n\n        result = {\"value\": None}\n\n        def on_ok():\n            result[\"value\"] = entry.get().strip()\n            dialog.destroy()\n\n        def on_cancel():\n            dialog.destroy()\n\n        btn_frame = ttk.Frame(dialog)\n        btn_frame.grid(row=2, column=0, pady=5)\n        ttk.Button(btn_frame, text=\"OK\", command=on_ok).grid(row=0, column=0, padx=5)\n        ttk.Button(btn_frame, text=\"Annuler\", command=on_cancel).grid(row=0, column=1, padx=5)\n\n        dialog.wait_window()\n        return result[\"value\"]\n\n    def _show_result_window(self, title: str, text: str):\n        win = tk.Toplevel(self)\n        win.title(title)\n        win.geometry(\"800x600\")\n        txt = tk.Text(win, wrap=\"word\")\n        txt.pack(fill=\"both\", expand=True)\n        txt.insert(\"1.0\", text)\n        txt.config(state=\"disabled\")\n",
    "interface\\__init__.py": "",
    "src\\client_logic.py": "import os\nimport subprocess\nfrom typing import List, Optional\nfrom src.server_logic import ServerLogic\n\n\nclass ClientLogic:\n    def __init__(self):\n        self.project_root: Optional[str] = None\n        self.server: Optional[ServerLogic] = None\n        self.selected_version: Optional[str] = None\n        self.selected_files: List[str] = []\n\n    # ---------- Projet ----------\n\n    def select_project(self, path: str) -> None:\n        self.project_root = path\n        self.server = ServerLogic(path)\n\n    def has_project(self) -> bool:\n        return self.server is not None\n\n    def open_project_folder(self) -> None:\n        if not self.project_root:\n            return\n        if os.name == \"nt\":  # Windows\n            os.startfile(self.project_root)\n        elif os.name == \"posix\":  # macOS / Linux\n            subprocess.Popen([\"open\" if sys.platform == \"darwin\" else \"xdg-open\", self.project_root])\n\n    # ---------- Extraction ----------\n\n    def extract_full_project(self) -> str:\n        if not self.server:\n            raise RuntimeError(\"Aucun projet sélectionné.\")\n        snapshot = self.server.scan_project()\n        self.server.save_snapshot(snapshot)\n        self.server.export_full_context(snapshot)\n        self.selected_version = snapshot.version\n        return snapshot.version\n\n    # ---------- Versions ----------\n\n    def get_available_versions(self) -> List[str]:\n        if not self.server:\n            return []\n        return self.server.list_versions()\n\n    def select_version(self, version: str) -> None:\n        self.selected_version = version\n\n    def delete_selected_version(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        self.server.delete_version(self.selected_version)\n        self.selected_version = None\n\n    # ---------- Fichiers ----------\n\n    def get_files_from_selected_version(self) -> List[str]:\n        if not self.server or not self.selected_version:\n            return []\n        snapshot = self.server.load_snapshot(self.selected_version)\n        return sorted(snapshot.files_content.keys())\n\n    def set_selected_files(self, files: List[str]) -> None:\n        self.selected_files = files\n\n    # ---------- Export sélection ----------\n\n    def export_selected_markdown_and_html(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.export_selected_context(snapshot, self.selected_files)\n\n    # ---------- Restauration ----------\n\n    def restore_full_version(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.restore_all(snapshot)\n\n    def restore_selected_files(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.restore_selected(snapshot, self.selected_files)\n",
    "src\\queries_logic.py": "import os\nimport webbrowser\nfrom typing import List, Dict, Callable, Optional\n\nfrom data.queries_manager import QueriesManager\n\n\nclass QueriesLogic:\n    def __init__(\n        self,\n        manager: QueriesManager,\n        copy_to_clipboard: Callable[[str], None],\n        get_selected_files: Callable[[], List[str]],\n        base_path: Optional[str] = None,\n    ):\n        self.manager = manager\n        self.copy_to_clipboard = copy_to_clipboard\n        self.get_selected_files = get_selected_files\n\n        if base_path is None:\n            base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n        self.base_path = base_path\n        self.context_html_path = os.path.join(\n            self.base_path, \"code_source\", \"selected_context.html\"\n        )\n\n    # ---------- Construction des requêtes ----------\n\n    def build_edge_query(self, query: Dict, version: Dict) -> str:\n        before = version.get(\"before\", \"\").strip()\n        after = version.get(\"after\", \"\").strip()\n\n        context_block = (\n            \"Interface: the context files are available in the @selected_context tab.\"\n        )\n\n        parts = [p for p in [before, context_block, after] if p]\n        return \"\\n\\n\".join(parts)\n\n    def build_github_query(self, query: Dict, version: Dict) -> str:\n        before = version.get(\"before\", \"\").strip()\n        after = version.get(\"after\", \"\").strip()\n\n        selected_files = self.get_selected_files()  # liste de chemins relatifs\n        if selected_files:\n            context_lines = [f\"@{path}\" for path in selected_files]\n            context_block = \"Context files:\\n\" + \"\\n\".join(context_lines)\n        else:\n            context_block = \"Context files: (no files selected)\"\n\n        parts = [p for p in [before, context_block, after] if p]\n        return \"\\n\\n\".join(parts)\n\n    # ---------- Actions ----------\n\n    def open_edge_context_html(self) -> None:\n        if os.path.exists(self.context_html_path):\n            webbrowser.open(self.context_html_path)\n\n    def generate_edge_copilot(self, query_name: str, version_number: str) -> str:\n        query = self.manager.get_query(query_name)\n        if query is None:\n            return \"\"\n        version = self.manager.get_version(query_name, version_number)\n        if version is None:\n            return \"\"\n\n        text = self.build_edge_query(query, version)\n        self.open_edge_context_html()\n        self.copy_to_clipboard(text)\n        return text\n\n    def generate_github_copilot(self, query_name: str, version_number: str) -> str:\n        query = self.manager.get_query(query_name)\n        if query is None:\n            return \"\"\n        version = self.manager.get_version(query_name, version_number)\n        if version is None:\n            return \"\"\n\n        text = self.build_github_query(query, version)\n        self.copy_to_clipboard(text)\n        return text\n",
    "src\\server_logic.py": "import os\nfrom typing import List, Dict, Tuple\nfrom data.models import ProjectPaths, ExclusionRules, ProjectSnapshot\nfrom data.utils import (\n    save_json,\n    load_json,\n    generate_markdown,\n    generate_html,\n    get_next_version_number,\n    list_existing_versions,\n    delete_version_files,\n)\n\n\nclass ServerLogic:\n    def __init__(self, project_root: str):\n        self.paths = ProjectPaths(project_root)\n        self.exclusions = ExclusionRules()\n        self._ensure_code_source()\n\n    # ---------- Initialisation / exclusions ----------\n\n    def _ensure_code_source(self) -> None:\n        os.makedirs(self.paths.code_source, exist_ok=True)\n        if not os.path.exists(self.paths.exclude_file):\n            with open(self.paths.exclude_file, \"w\", encoding=\"utf-8\") as f:\n                f.write(\"\\n\".join(sorted(self.exclusions.defaults)))\n\n    def load_exclusions(self) -> None:\n        self.exclusions.custom.clear()\n        if os.path.exists(self.paths.exclude_file):\n            with open(self.paths.exclude_file, \"r\", encoding=\"utf-8\") as f:\n                for line in f:\n                    line = line.strip()\n                    if line:\n                        self.exclusions.custom.add(line)\n\n    # ---------- Scan / snapshot ----------\n\n    def scan_project(self) -> ProjectSnapshot:\n        self.load_exclusions()\n        organisation: Dict[str, Dict[str, List[str]]] = {}\n        files_content: Dict[str, str] = {}\n\n        for current_root, dirs, files in os.walk(self.paths.root):\n            rel_root = os.path.relpath(current_root, self.paths.root)\n            if rel_root == \".\":\n                rel_root = \"\"\n\n            dirs[:] = [d for d in dirs if not self.exclusions.should_exclude(d)]\n\n            organisation[rel_root] = {\n                \"dirs\": dirs.copy(),\n                \"files\": [f for f in files if not self.exclusions.should_exclude(f)],\n            }\n\n            for f in files:\n                if self.exclusions.should_exclude(f):\n                    continue\n                rel_path = os.path.join(rel_root, f) if rel_root else f\n                file_path = os.path.join(current_root, f)\n                try:\n                    with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as fp:\n                        files_content[rel_path] = fp.read()\n                except Exception:\n                    files_content[rel_path] = \"<< Impossible de lire ce fichier >>\"\n\n        version = get_next_version_number(self.paths.code_source)\n        return ProjectSnapshot(version=version, organisation=organisation, files_content=files_content)\n\n    # ---------- Sauvegarde / chargement snapshot ----------\n\n    def save_snapshot(self, snapshot: ProjectSnapshot) -> None:\n        save_json(self.paths.organisation_json(snapshot.version), snapshot.organisation)\n        save_json(self.paths.files_content_json(snapshot.version), snapshot.files_content)\n\n    def load_snapshot(self, version: str) -> ProjectSnapshot:\n        org = load_json(self.paths.organisation_json(version))\n        fc = load_json(self.paths.files_content_json(version))\n        return ProjectSnapshot(version=version, organisation=org, files_content=fc)\n\n    # ---------- Exports ----------\n\n    def export_full_context(self, snapshot: ProjectSnapshot) -> None:\n        md = generate_markdown(snapshot)\n        html = generate_html(snapshot)\n        with open(self.paths.context_md, \"w\", encoding=\"utf-8\") as f:\n            f.write(md)\n        with open(self.paths.context_html, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n\n    def export_selected_context(self, snapshot: ProjectSnapshot, selected_files: List[str]) -> None:\n        from data.utils import filter_snapshot\n        filtered = filter_snapshot(snapshot, selected_files)\n        md = generate_markdown(filtered)\n        html = generate_html(filtered)\n        with open(self.paths.selected_context_md, \"w\", encoding=\"utf-8\") as f:\n            f.write(md)\n        with open(self.paths.selected_context_html, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n\n    # ---------- Versioning ----------\n\n    def list_versions(self) -> List[str]:\n        return list_existing_versions(self.paths.code_source)\n\n    def delete_version(self, version: str) -> None:\n        delete_version_files(self.paths.code_source, version)\n\n    # ---------- Restauration ----------\n\n    def restore_all(self, snapshot: ProjectSnapshot) -> None:\n        for rel_path, content in snapshot.files_content.items():\n            abs_path = os.path.join(self.paths.root, rel_path)\n            os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n            with open(abs_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n    def restore_selected(self, snapshot: ProjectSnapshot, selected_files: List[str]) -> None:\n        selected_set = set(selected_files)\n        for rel_path, content in snapshot.files_content.items():\n            if rel_path not in selected_set:\n                continue\n            abs_path = os.path.join(self.paths.root, rel_path)\n            os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n            with open(abs_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)",
    "src\\__init__.py": ""
}