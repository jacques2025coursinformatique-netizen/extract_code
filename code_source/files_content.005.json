{
    "extract_code.spec": "# -*- mode: python ; coding: utf-8 -*-\n\n\na = Analysis(\n    ['main.py'],\n    pathex=[],\n    binaries=[],\n    datas=[],\n    hiddenimports=[],\n    hookspath=[],\n    hooksconfig={},\n    runtime_hooks=[],\n    excludes=[],\n    noarchive=False,\n    optimize=0,\n)\npyz = PYZ(a.pure)\n\nexe = EXE(\n    pyz,\n    a.scripts,\n    a.binaries,\n    a.datas,\n    [],\n    name='extract_code',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    upx_exclude=[],\n    runtime_tmpdir=None,\n    console=False,\n    disable_windowed_traceback=False,\n    argv_emulation=False,\n    target_arch=None,\n    codesign_identity=None,\n    entitlements_file=None,\n)\n",
    "main.py": "from tkinter import Tk\nfrom interface.ui import ApplicationUI\n\n\ndef main():\n    root = Tk()\n    app = ApplicationUI(root)\n    root.mainloop()\n\n\nif __name__ == \"__main__\":\n    main()",
    "requirements.txt": "tk\npyinstaller",
    "data\\categories.json": "{\n    \"categories\": [\n        \"Essai\",\n        \"Essai2\"\n    ]\n}",
    "data\\models.py": "import os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Set, Optional\n\n\nDEFAULT_EXCLUDES = [\"venv\", \"code_source\", \"archive\", \".env\",\".venv\",\".git\",\"__pycache__\",\".python-version\",\"dist\",\"build\",\"main.spec\"]\n\n\n@dataclass\nclass ProjectPaths:\n    root: str\n\n    @property\n    def code_source(self) -> str:\n        return os.path.join(self.root, \"code_source\")\n\n    @property\n    def exclude_file(self) -> str:\n        return os.path.join(self.code_source, \"exclude.txt\")\n\n    def organisation_json(self, version: str) -> str:\n        return os.path.join(self.code_source, f\"organisation.{version}.json\")\n\n    def files_content_json(self, version: str) -> str:\n        return os.path.join(self.code_source, f\"files_content.{version}.json\")\n\n    @property\n    def context_md(self) -> str:\n        return os.path.join(self.code_source, \"context.md\")\n\n    @property\n    def context_html(self) -> str:\n        return os.path.join(self.code_source, \"context.html\")\n\n    @property\n    def selected_context_md(self) -> str:\n        return os.path.join(self.code_source, \"selected_context.md\")\n\n    @property\n    def selected_context_html(self) -> str:\n        return os.path.join(self.code_source, \"selected_context.html\")\n\n\n@dataclass\nclass FileEntry:\n    relative_path: str\n    content: str\n\n\n@dataclass\nclass ProjectSnapshot:\n    version: str\n    organisation: Dict[str, Dict[str, List[str]]]\n    files_content: Dict[str, str]\n\n\n@dataclass\nclass ExclusionRules:\n    defaults: Set[str] = field(default_factory=lambda: set(DEFAULT_EXCLUDES))\n    custom: Set[str] = field(default_factory=set)\n\n    def all(self) -> Set[str]:\n        return self.defaults.union(self.custom)\n\n    def should_exclude(self, name: str) -> bool:\n        for ex in self.all():\n            if name == ex or name.startswith(ex):\n                return True\n        return False\n",
    "data\\queries.json": "{\n    \"queries\": [\n        {\n            \"name\": \"Essai\",\n            \"description\": \"Description\",\n            \"category\": \"Essai\",\n            \"context_files\": \"@config @database\",\n            \"versions\": [\n                {\n                    \"version\": \"001\",\n                    \"before\": \"Partie \\tamont\",\n                    \"after\": \"Partie aval\"\n                },\n                {\n                    \"version\": \"002\",\n                    \"before\": \"Partie \\tamont\",\n                    \"after\": \"Partie aval2\"\n                }\n            ]\n        }\n    ]\n}",
    "data\\queries_manager.py": "import json\nimport os\nfrom typing import Dict, List, Optional, Any\n\n\nclass QueriesManager:\n    \"\"\"\n    Fichiers utilisés :\n\n    data/categories.json\n    {\n        \"categories\": [\n            \"Backend\",\n            \"Frontend\"\n        ]\n    }\n    ou\n    [\n        \"Backend\",\n        \"Frontend\"\n    ]\n\n    data/queries.json\n    {\n        \"queries\": [\n            {\n                \"name\": \"Refactor service\",\n                \"description\": \"…\",\n                \"category\": \"Backend\",\n                \"context_files\": \"@config @service\",\n                \"versions\": [\n                    {\"version\": \"001\", \"before\": \"...\", \"after\": \"...\"},\n                    {\"version\": \"002\", \"before\": \"...\", \"after\": \"...\"}\n                ]\n            }\n        ]\n    }\n    ou\n    [\n        { ... }\n    ]\n    \"\"\"\n\n    def __init__(self, base_dir: Optional[str] = None):\n        # On force toujours l'utilisation du dossier data du projet\n        if base_dir is None:\n            data_dir = os.path.dirname(os.path.abspath(__file__))  # .../data\n        else:\n            # base_dir peut être la racine du projet ou déjà data\n            if os.path.basename(base_dir) == \"data\":\n                data_dir = base_dir\n            else:\n                data_dir = os.path.join(base_dir, \"data\")\n\n        self.categories_path = os.path.join(data_dir, \"categories.json\")\n        self.queries_path = os.path.join(data_dir, \"queries.json\")\n\n        self.categories: List[str] = []\n        self.queries: List[Dict[str, Any]] = []\n\n        self.load_all()\n\n    # ------------------------------------------------------------------ #\n    # Chargement / sauvegarde\n    # ------------------------------------------------------------------ #\n\n    def load_all(self) -> None:\n        self.categories = self._load_categories(self.categories_path)\n        self.queries = self._load_queries(self.queries_path)\n\n    def save_all(self) -> None:\n        self._save_categories(self.categories_path, self.categories)\n        self._save_queries(self.queries_path, self.queries)\n\n    def _load_categories(self, path: str) -> List[str]:\n        if not os.path.exists(path):\n            return []\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n        if isinstance(data, dict) and \"categories\" in data:\n            return list(data[\"categories\"])\n        if isinstance(data, list):\n            return data\n        return []\n\n    def _save_categories(self, path: str, categories: List[str]) -> None:\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            json.dump({\"categories\": categories}, f, indent=4, ensure_ascii=False)\n\n    def _load_queries(self, path: str) -> List[Dict[str, Any]]:\n        if not os.path.exists(path):\n            return []\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n        if isinstance(data, dict) and \"queries\" in data:\n            return list(data[\"queries\"])\n        if isinstance(data, list):\n            return data\n        return []\n\n    def _save_queries(self, path: str, queries: List[Dict[str, Any]]) -> None:\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            json.dump({\"queries\": queries}, f, indent=4, ensure_ascii=False)\n\n    # ------------------------------------------------------------------ #\n    # Import / export\n    # ------------------------------------------------------------------ #\n\n    def import_categories(self, path: str) -> None:\n        self.categories = self._load_categories(path)\n        self.save_all()\n\n    def export_categories(self, path: str) -> None:\n        self._save_categories(path, self.categories)\n\n    def import_queries(self, path: str) -> None:\n        self.queries = self._load_queries(path)\n        self.save_all()\n\n    def export_queries(self, path: str) -> None:\n        self._save_queries(path, self.queries)\n\n    # ------------------------------------------------------------------ #\n    # Catégories\n    # ------------------------------------------------------------------ #\n\n    def get_categories(self) -> List[str]:\n        return list(self.categories)\n\n    def add_category(self, name: str) -> None:\n        if name and name not in self.categories:\n            self.categories.append(name)\n            self.save_all()\n\n    def delete_category(self, name: str) -> None:\n        if name in self.categories:\n            self.categories.remove(name)\n            self.queries = [q for q in self.queries if q.get(\"category\") != name]\n            self.save_all()\n\n    def rename_category(self, old: str, new: str) -> None:\n        if old in self.categories and new:\n            idx = self.categories.index(old)\n            self.categories[idx] = new\n            for q in self.queries:\n                if q.get(\"category\") == old:\n                    q[\"category\"] = new\n            self.save_all()\n\n    # ------------------------------------------------------------------ #\n    # Requêtes\n    # ------------------------------------------------------------------ #\n\n    def get_all_query_names(self) -> List[str]:\n        return [q.get(\"name\", \"\") for q in self.queries]\n\n    def get_queries_for_category(self, category: str) -> List[str]:\n        return [\n            q.get(\"name\", \"\")\n            for q in self.queries\n            if q.get(\"category\") == category\n        ]\n\n    def _find_query(self, category: str, name: str) -> Optional[Dict[str, Any]]:\n        for q in self.queries:\n            if q.get(\"category\") == category and q.get(\"name\") == name:\n                return q\n        return None\n\n    def get_query(self, name: str) -> Optional[Dict[str, Any]]:\n        for q in self.queries:\n            if q.get(\"name\") == name:\n                return q\n        return None\n\n    def add_query(self, category: str, name: str) -> None:\n        if not category or not name:\n            return\n        if self._find_query(category, name) is not None:\n            return\n        self.queries.append(\n            {\n                \"name\": name,\n                \"description\": \"\",\n                \"category\": category,\n                \"context_files\": \"\",\n                \"versions\": [],\n            }\n        )\n        self.save_all()\n\n    def delete_query(self, category: str, name: str) -> None:\n        before = len(self.queries)\n        self.queries = [\n            q for q in self.queries\n            if not (q.get(\"category\") == category and q.get(\"name\") == name)\n        ]\n        if len(self.queries) != before:\n            self.save_all()\n\n    def rename_query(self, category: str, old: str, new: str) -> None:\n        q = self._find_query(category, old)\n        if q is not None and new:\n            q[\"name\"] = new\n            self.save_all()\n\n    # ------------------------------------------------------------------ #\n    # Versions (liste de dicts {version,before,after})\n    # ------------------------------------------------------------------ #\n\n    def get_versions_for_query(self, category: str, name: str) -> List[str]:\n        q = self._find_query(category, name)\n        if not q:\n            return []\n        versions = q.get(\"versions\", [])\n        return [v.get(\"version\", \"\") for v in versions]\n\n    def get_version(self, query_name: str, version_number: str) -> Optional[Dict[str, Any]]:\n        q = self.get_query(query_name)\n        if not q:\n            return None\n        for v in q.get(\"versions\", []):\n            if v.get(\"version\") == version_number:\n                return v\n        return None\n\n    def get_version_content(self, category: str, name: str, version: str) -> str:\n        q = self._find_query(category, name)\n        if not q:\n            return \"\"\n        for v in q.get(\"versions\", []):\n            if v.get(\"version\") == version:\n                before = v.get(\"before\", \"\") or \"\"\n                after = v.get(\"after\", \"\") or \"\"\n                if before and after:\n                    return before.rstrip() + \"\\n\\n\" + after.lstrip()\n                return (before or after) or \"\"\n        return \"\"\n\n    def set_version_content(self, category: str, name: str, version: str, content: str) -> None:\n        q = self._find_query(category, name)\n        if not q:\n            return\n        versions = q.setdefault(\"versions\", [])\n        for v in versions:\n            if v.get(\"version\") == version:\n                v[\"before\"] = content\n                v[\"after\"] = v.get(\"after\", \"\")\n                self.save_all()\n                return\n        versions.append(\n            {\n                \"version\": version,\n                \"before\": content,\n                \"after\": \"\",\n            }\n        )\n        self.save_all()\n\n    def delete_version(self, category: str, name: str, version: str) -> None:\n        q = self._find_query(category, name)\n        if not q:\n            return\n        versions = q.get(\"versions\", [])\n        new_versions = [v for v in versions if v.get(\"version\") != version]\n        if len(new_versions) != len(versions):\n            q[\"versions\"] = new_versions\n            self.save_all()\n\n    def rename_version(\n        self,\n        category: str,\n        name: str,\n        old_version: str,\n        new_version: str,\n        new_content: Optional[str] = None,\n    ) -> None:\n        q = self._find_query(category, name)\n        if not q:\n            return\n        versions = q.setdefault(\"versions\", [])\n        for v in versions:\n            if v.get(\"version\") == old_version:\n                v[\"version\"] = new_version\n                if new_content is not None:\n                    v[\"before\"] = new_content\n                self.save_all()\n                return\n",
    "data\\utils.py": "import os\nimport json\nfrom typing import Dict, List, Tuple\nfrom .models import ProjectSnapshot\n\n\ndef load_json(path: str) -> Dict:\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n\n\ndef save_json(path: str, data: Dict) -> None:\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=4, ensure_ascii=False)\n\n\ndef list_existing_versions(code_source_dir: str) -> List[str]:\n    if not os.path.isdir(code_source_dir):\n        return []\n    versions = set()\n    for name in os.listdir(code_source_dir):\n        if name.startswith(\"organisation.\") and name.endswith(\".json\"):\n            middle = name[len(\"organisation.\"):-len(\".json\")]\n            versions.add(middle)\n    return sorted(versions)\n\n\ndef get_next_version_number(code_source_dir: str) -> str:\n    versions = list_existing_versions(code_source_dir)\n    if not versions:\n        return \"001\"\n    last = max(int(v) for v in versions)\n    return f\"{last + 1:03d}\"\n\n\ndef delete_version_files(code_source_dir: str, version: str) -> None:\n    org = os.path.join(code_source_dir, f\"organisation.{version}.json\")\n    fc = os.path.join(code_source_dir, f\"files_content.{version}.json\")\n    for path in (org, fc):\n        if os.path.exists(path):\n            os.remove(path)\n\n\ndef generate_markdown(snapshot: ProjectSnapshot) -> str:\n    md = \"# Organisation du projet\\n\\n\"\n    for folder, content in snapshot.organisation.items():\n        md += f\"## {folder}\\n\"\n        md += \"**Dossiers :**\\n\"\n        for d in content.get(\"dirs\", []):\n            md += f\"- {d}\\n\"\n        md += \"\\n**Fichiers :**\\n\"\n        for f in content.get(\"files\", []):\n            md += f\"- {f}\\n\"\n        md += \"\\n---\\n\"\n\n    md += \"\\n# Contenu des fichiers\\n\\n\"\n    for filepath, text in snapshot.files_content.items():\n        md += f\"## {filepath}\\n\\n\"\n        md += \"```text\\n\"\n        md += text\n        md += \"\\n```\\n\\n\"\n    return md\n\n\ndef generate_html(snapshot: ProjectSnapshot) -> str:\n    \"\"\"\n    Version adaptée à Copilot :\n    - HTML simple, non échappé\n    - structure proche du Markdown\n    - lisible comme un document texte dans Edge\n    \"\"\"\n    parts: List[str] = []\n    parts.append(\"<!DOCTYPE html>\")\n    parts.append(\"<html>\")\n    parts.append(\"<head><meta charset='utf-8'><title>Context</title></head>\")\n    parts.append(\"<body>\")\n    parts.append(\"<h1>Organisation du projet</h1>\")\n\n    for folder, content in snapshot.organisation.items():\n        parts.append(f\"<h2>{folder}</h2>\")\n        parts.append(\"<h3>Dossiers :</h3><ul>\")\n        for d in content.get(\"dirs\", []):\n            parts.append(f\"<li>{d}</li>\")\n        parts.append(\"</ul>\")\n        parts.append(\"<h3>Fichiers :</h3><ul>\")\n        for f in content.get(\"files\", []):\n            parts.append(f\"<li>{f}</li>\")\n        parts.append(\"</ul><hr>\")\n\n    parts.append(\"<h1>Contenu des fichiers</h1>\")\n    for filepath, text in snapshot.files_content.items():\n        parts.append(f\"<h2>{filepath}</h2>\")\n        parts.append(\"<pre>\")\n        parts.append(text)\n        parts.append(\"</pre>\")\n\n    parts.append(\"</body></html>\")\n    return \"\\n\".join(parts)\n\n\ndef escape_html(text: str) -> str:\n    # Gardée pour compatibilité éventuelle, mais plus utilisée dans generate_html\n    return (\n        text.replace(\"&\", \"&amp;\")\n        .replace(\"<\", \"&lt;\")\n        .replace(\">\", \"&gt;\")\n    )\n\n\ndef filter_snapshot(snapshot: ProjectSnapshot, selected_files: List[str]) -> ProjectSnapshot:\n    selected_set = set(selected_files)\n    filtered_files = {\n        path: content\n        for path, content in snapshot.files_content.items()\n        if path in selected_set\n    }\n\n    filtered_org: Dict[str, Dict[str, List[str]]] = {}\n    for folder, content in snapshot.organisation.items():\n        files = [f for f in content.get(\"files\", []) if os.path.join(folder, f) in selected_set]\n        if files:\n            filtered_org[folder] = {\n                \"dirs\": content.get(\"dirs\", []),\n                \"files\": files,\n            }\n\n    return ProjectSnapshot(\n        version=snapshot.version,\n        organisation=filtered_org,\n        files_content=filtered_files,\n    )\n",
    "data\\__init__.py": "",
    "interface\\ui.py": "import os\nfrom tkinter import (\n    Tk,\n    Frame,\n    Label,\n    Listbox,\n    Scrollbar,\n    SINGLE,\n    MULTIPLE,\n    END,\n    filedialog,\n    messagebox,\n    RIGHT,\n    LEFT,\n    Y,\n    BOTH,\n    Text,\n)\nfrom tkinter import ttk\n\nfrom src.client_logic import ClientLogic\n\nfrom data.queries_manager import QueriesManager\nfrom src.queries_logic import QueriesLogic\nfrom interface.ui_queries import QueriesUI\n\n\nclass ApplicationUI:\n    def __init__(self, root: Tk):\n        self.root = root\n        self.root.title(\"Gestion de contexte projet\")\n\n        # --- Thème moderne ---\n        style = ttk.Style()\n        style.theme_use(\"clam\")\n\n        self.client = ClientLogic()\n\n        # Manager / logique pour les requêtes type\n        self._init_queries_module()\n\n        # Widgets principaux\n        self.preview_text = None\n        self.list_versions = None\n        self.list_files = None\n\n        self._build_layout()\n\n    # -------------------------------------------------------------------------\n    #  INITIALISATION MODULE REQUÊTES TYPE\n    # -------------------------------------------------------------------------\n    def _init_queries_module(self):\n        self.queries_manager = QueriesManager()\n\n        def copy_to_clipboard(text: str):\n            self.root.clipboard_clear()\n            self.root.clipboard_append(text)\n\n        def get_selected_files():\n            return self.get_selected_files()\n\n        self.queries_logic = QueriesLogic(\n            manager=self.queries_manager,\n            copy_to_clipboard=copy_to_clipboard,\n            get_selected_files=get_selected_files,\n        )\n\n        self.queries_ui = None  # sera créé dans le layout\n\n    # -------------------------------------------------------------------------\n    #  LAYOUT GLOBAL : PANEDWINDOW + NOTEBOOK + COLONNE DROITE\n    # -------------------------------------------------------------------------\n    def _build_layout(self):\n        # PanedWindow horizontal : gauche = Notebook, droite = fichiers/preview\n        paned = ttk.PanedWindow(self.root, orient=\"horizontal\")\n        paned.pack(fill=\"both\", expand=True)\n\n        # Frame gauche : Notebook\n        frame_left = Frame(paned)\n        paned.add(frame_left, weight=1)\n\n        # Frame droite : fichiers + preview\n        frame_right = Frame(paned)\n        paned.add(frame_right, weight=2)\n\n        # ---------------------------------------------------------------------\n        # NOTEBOOK À GAUCHE : Onglet Projet + Onglet Requêtes type\n        # ---------------------------------------------------------------------\n        self.notebook = ttk.Notebook(frame_left)\n        self.notebook.pack(fill=\"both\", expand=True, padx=10, pady=10)\n\n        # Onglet Projet\n        self.tab_project = Frame(self.notebook)\n        self.notebook.add(self.tab_project, text=\"Projet\")\n\n        # Onglet Requêtes type\n        self.tab_queries = Frame(self.notebook)\n        self.notebook.add(self.tab_queries, text=\"Requêtes type\")\n\n        # Construire le contenu de l’onglet Projet\n        self._build_project_tab(self.tab_project)\n\n        # Construire le contenu de l’onglet Requêtes type\n        self._build_queries_tab(self.tab_queries)\n\n        # ---------------------------------------------------------------------\n        # COLONNE DROITE : Fichiers + Prévisualisation + Actions\n        # ---------------------------------------------------------------------\n        self._build_right_column(frame_right)\n\n    # -------------------------------------------------------------------------\n    #  ONGLET PROJET\n    # -------------------------------------------------------------------------\n    def _build_project_tab(self, parent: Frame):\n        Label(parent, text=\"Projet\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n        ttk.Button(parent, text=\"Sélectionner un dossier\", command=self.on_select_project).pack(pady=5)\n        ttk.Button(parent, text=\"Ouvrir le dossier sélectionné\", command=self.on_open_folder).pack(pady=5)\n\n        Label(parent, text=\"Extraction complète\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n        ttk.Button(parent, text=\"Extraire l'ensemble du projet\", command=self.on_extract_full).pack(pady=5)\n\n        Label(parent, text=\"Versions disponibles\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_versions = Frame(parent)\n        frame_versions.pack(fill=\"both\", expand=True)\n\n        self.list_versions = Listbox(frame_versions, selectmode=SINGLE, height=10)\n        self.list_versions.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_versions = Scrollbar(frame_versions, orient=\"vertical\", command=self.list_versions.yview)\n        scroll_versions.pack(side=RIGHT, fill=Y)\n\n        self.list_versions.config(yscrollcommand=scroll_versions.set)\n        self.list_versions.bind(\"<<ListboxSelect>>\", self.on_select_version)\n\n        ttk.Button(parent, text=\"Restaurer la version sélectionnée\", command=self.on_restore_full).pack(pady=5)\n        ttk.Button(parent, text=\"Supprimer la version sélectionnée\", command=self.on_delete_version).pack(pady=5)\n\n    # -------------------------------------------------------------------------\n    #  ONGLET REQUÊTES TYPE\n    # -------------------------------------------------------------------------\n    def _build_queries_tab(self, parent: Frame):\n        # On insère directement QueriesUI dans cet onglet\n        self.queries_ui = QueriesUI(\n            parent,\n            manager=self.queries_manager,\n            logic=self.queries_logic,\n        )\n        self.queries_ui.pack(fill=\"both\", expand=True, padx=5, pady=5)\n\n    # -------------------------------------------------------------------------\n    #  COLONNE DROITE : FICHIERS + PRÉVISUALISATION + ACTIONS\n    # -------------------------------------------------------------------------\n    def _build_right_column(self, parent: Frame):\n        Label(parent, text=\"Fichiers de la version sélectionnée\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_files = Frame(parent)\n        frame_files.pack(fill=\"both\", expand=False, padx=10, pady=5)\n\n        self.list_files = Listbox(frame_files, selectmode=MULTIPLE, height=12)\n        self.list_files.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_files = Scrollbar(frame_files, orient=\"vertical\", command=self.list_files.yview)\n        scroll_files.pack(side=RIGHT, fill=Y)\n\n        self.list_files.config(yscrollcommand=scroll_files.set)\n        self.list_files.bind(\"<<ListboxSelect>>\", self.on_file_selected)\n\n        Label(parent, text=\"Prévisualisation du fichier\", font=(\"Segoe UI\", 11, \"bold\")).pack(pady=5)\n\n        frame_preview = Frame(parent)\n        frame_preview.pack(fill=\"both\", expand=True, padx=10, pady=5)\n\n        self.preview_text = Text(frame_preview, wrap=\"word\", height=20)\n        self.preview_text.pack(side=LEFT, fill=BOTH, expand=True)\n\n        scroll_preview = Scrollbar(frame_preview, orient=\"vertical\", command=self.preview_text.yview)\n        scroll_preview.pack(side=RIGHT, fill=Y)\n\n        self.preview_text.config(yscrollcommand=scroll_preview.set)\n\n        ttk.Button(parent, text=\"Créer selected_context.md & .html\", command=self.on_export_selected).pack(pady=5)\n        ttk.Button(parent, text=\"Restaurer les fichiers sélectionnés\", command=self.on_restore_selected).pack(pady=5)\n\n    # -------------------------------------------------------------------------\n    #  ACTIONS ONGLET PROJET\n    # -------------------------------------------------------------------------\n    def on_select_project(self):\n        folder = filedialog.askdirectory()\n        if not folder:\n            return\n        self.client.select_project(folder)\n        messagebox.showinfo(\"Projet sélectionné\", f\"Dossier : {folder}\")\n        self.refresh_versions()\n\n    def on_open_folder(self):\n        try:\n            self.client.open_project_folder()\n        except Exception as e:\n            messagebox.showerror(\"Erreur\", str(e))\n\n    def on_extract_full(self):\n        if not self.client.has_project():\n            messagebox.showerror(\"Erreur\", \"Aucun projet sélectionné.\")\n            return\n        version = self.client.extract_full_project()\n        messagebox.showinfo(\"Extraction terminée\", f\"Version créée : {version}\")\n        self.refresh_versions()\n        self.select_version_in_list(version)\n\n    def refresh_versions(self):\n        if self.list_versions is None:\n            return\n        self.list_versions.delete(0, END)\n        versions = self.client.get_available_versions()\n        for v in versions:\n            self.list_versions.insert(END, v)\n\n    def on_select_version(self, event=None):\n        selection = self.list_versions.curselection()\n        if not selection:\n            return\n        index = selection[0]\n        version = self.list_versions.get(index)\n        self.client.select_version(version)\n        self.refresh_files()\n\n    def on_restore_full(self):\n        try:\n            self.client.restore_full_version()\n            messagebox.showinfo(\"Restauration\", \"Restauration complète effectuée.\")\n        except Exception as e:\n            messagebox.showerror(\"Erreur\", str(e))\n\n    def on_delete_version(self):\n        self.client.delete_selected_version()\n        self.refresh_versions()\n        if self.list_files is not None:\n            self.list_files.delete(0, END)\n        if self.preview_text is not None:\n            self.preview_text.delete(1.0, END)\n\n    # -------------------------------------------------------------------------\n    #  ACTIONS COLONNE DROITE\n    # -------------------------------------------------------------------------\n    def refresh_files(self):\n        if self.list_files is None:\n            return\n        self.list_files.delete(0, END)\n        files = self.client.get_files_from_selected_version()\n        for f in files:\n            self.list_files.insert(END, f)\n        if self.preview_text is not None:\n            self.preview_text.delete(1.0, END)\n\n    def on_file_selected(self, event=None):\n        selection = self.list_files.curselection()\n        if not selection:\n            self.preview_text.delete(1.0, END)\n            return\n\n        index = selection[0]\n        filename = self.list_files.get(index)\n\n        snapshot = self.client.server.load_snapshot(self.client.selected_version)\n        content = snapshot.files_content.get(filename, \"\")\n\n        self.preview_text.delete(1.0, END)\n        self.preview_text.insert(END, content)\n\n    def on_export_selected(self):\n        selected_indices = self.list_files.curselection()\n        files = [self.list_files.get(i) for i in selected_indices]\n        self.client.set_selected_files(files)\n        self.client.export_selected_markdown_and_html()\n        messagebox.showinfo(\"Export\", \"selected_context.md et selected_context.html générés.\")\n\n    def on_restore_selected(self):\n        selected_indices = self.list_files.curselection()\n        files = [self.list_files.get(i) for i in selected_indices]\n        self.client.set_selected_files(files)\n        self.client.restore_selected_files()\n        messagebox.showinfo(\"Restauration\", \"Fichiers sélectionnés restaurés.\")\n\n    # -------------------------------------------------------------------------\n    #  HELPERS\n    # -------------------------------------------------------------------------\n    def get_selected_files(self):\n        \"\"\"\n        Utilisé par QueriesLogic pour récupérer les fichiers sélectionnés\n        dans la colonne droite.\n        \"\"\"\n        if self.list_files is None:\n            return []\n        selected_indices = self.list_files.curselection()\n        return [self.list_files.get(i) for i in selected_indices]\n\n    def select_version_in_list(self, version: str):\n        if self.list_versions is None:\n            return\n        for i in range(self.list_versions.size()):\n            if self.list_versions.get(i) == version:\n                self.list_versions.selection_clear(0, END)\n                self.list_versions.selection_set(i)\n                self.list_versions.activate(i)\n                self.on_select_version()\n                break\n",
    "interface\\ui_queries.py": "from tkinter import (\n    Frame,\n    Label,\n    Listbox,\n    Scrollbar,\n    SINGLE,\n    END,\n    BOTH,\n    LEFT,\n    RIGHT,\n    Y,\n    Text,\n    StringVar,\n)\nfrom tkinter import ttk, filedialog, messagebox\n\nfrom data.queries_manager import QueriesManager\n\n\nclass QueriesUI(Frame):\n    def __init__(self, parent, manager: QueriesManager, logic):\n        super().__init__(parent)\n        self.manager = manager\n        self.logic = logic  # QueriesLogic\n\n        self.current_category: str | None = None\n        self.current_query: str | None = None\n        self.current_version: str | None = None\n\n        self.var_category = StringVar()\n        self.var_query = StringVar()\n        self.var_version = StringVar()\n\n        self._build_ui()\n        self._refresh_categories()\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    # ------------------------------------------------------------------ #\n    # Construction UI\n    # ------------------------------------------------------------------ #\n\n    def _build_ui(self):\n        main_paned = ttk.PanedWindow(self, orient=\"horizontal\")\n        main_paned.pack(fill=BOTH, expand=True)\n\n        frame_left = Frame(main_paned)\n        frame_right = Frame(main_paned)\n        main_paned.add(frame_left, weight=1)\n        main_paned.add(frame_right, weight=2)\n\n        # ----------------- Colonne gauche : catégories / requêtes / versions\n        top_left = Frame(frame_left)\n        top_left.pack(fill=BOTH, expand=True, padx=5, pady=5)\n\n        # Catégories\n        Label(top_left, text=\"Catégories\", font=(\"Segoe UI\", 10, \"bold\")).pack(pady=2)\n        frame_cat = Frame(top_left)\n        frame_cat.pack(fill=BOTH, expand=True)\n\n        self.list_categories = Listbox(frame_cat, selectmode=SINGLE, height=6)\n        self.list_categories.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_cat = Scrollbar(frame_cat, orient=\"vertical\", command=self.list_categories.yview)\n        scroll_cat.pack(side=RIGHT, fill=Y)\n        self.list_categories.config(yscrollcommand=scroll_cat.set)\n        self.list_categories.bind(\"<<ListboxSelect>>\", self._on_category_selected)\n\n        btn_cat_bar = Frame(top_left)\n        btn_cat_bar.pack(fill=\"x\", pady=2)\n        ttk.Button(btn_cat_bar, text=\"Ajouter\", command=self._on_add_category).pack(side=LEFT, padx=2)\n        ttk.Button(btn_cat_bar, text=\"Renommer\", command=self._on_rename_category).pack(side=LEFT, padx=2)\n        ttk.Button(btn_cat_bar, text=\"Supprimer\", command=self._on_delete_category).pack(side=LEFT, padx=2)\n        ttk.Button(btn_cat_bar, text=\"Import\", command=self._on_import_categories).pack(side=LEFT, padx=2)\n        ttk.Button(btn_cat_bar, text=\"Export\", command=self._on_export_categories).pack(side=LEFT, padx=2)\n\n        # Requêtes\n        Label(top_left, text=\"Requêtes\", font=(\"Segoe UI\", 10, \"bold\")).pack(pady=2)\n        frame_req = Frame(top_left)\n        frame_req.pack(fill=BOTH, expand=True)\n\n        self.list_queries = Listbox(frame_req, selectmode=SINGLE, height=8)\n        self.list_queries.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_req = Scrollbar(frame_req, orient=\"vertical\", command=self.list_queries.yview)\n        scroll_req.pack(side=RIGHT, fill=Y)\n        self.list_queries.config(yscrollcommand=scroll_req.set)\n        self.list_queries.bind(\"<<ListboxSelect>>\", self._on_query_selected)\n\n        btn_req_bar = Frame(top_left)\n        btn_req_bar.pack(fill=\"x\", pady=2)\n        ttk.Button(btn_req_bar, text=\"Ajouter\", command=self._on_add_query).pack(side=LEFT, padx=2)\n        ttk.Button(btn_req_bar, text=\"Renommer\", command=self._on_rename_query).pack(side=LEFT, padx=2)\n        ttk.Button(btn_req_bar, text=\"Supprimer\", command=self._on_delete_query).pack(side=LEFT, padx=2)\n        ttk.Button(btn_req_bar, text=\"Import\", command=self._on_import_queries).pack(side=LEFT, padx=2)\n        ttk.Button(btn_req_bar, text=\"Export\", command=self._on_export_queries).pack(side=LEFT, padx=2)\n\n        # Versions\n        Label(top_left, text=\"Versions\", font=(\"Segoe UI\", 10, \"bold\")).pack(pady=2)\n        frame_ver = Frame(top_left)\n        frame_ver.pack(fill=BOTH, expand=True)\n\n        self.list_versions = Listbox(frame_ver, selectmode=SINGLE, height=6)\n        self.list_versions.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_ver = Scrollbar(frame_ver, orient=\"vertical\", command=self.list_versions.yview)\n        scroll_ver.pack(side=RIGHT, fill=Y)\n        self.list_versions.config(yscrollcommand=scroll_ver.set)\n        self.list_versions.bind(\"<<ListboxSelect>>\", self._on_version_selected)\n\n        btn_ver_bar = Frame(top_left)\n        btn_ver_bar.pack(fill=\"x\", pady=2)\n        ttk.Button(btn_ver_bar, text=\"Ajouter\", command=self._on_add_version).pack(side=LEFT, padx=2)\n        ttk.Button(btn_ver_bar, text=\"Renommer\", command=self._on_rename_version).pack(side=LEFT, padx=2)\n        ttk.Button(btn_ver_bar, text=\"Supprimer\", command=self._on_delete_version).pack(side=LEFT, padx=2)\n\n        # ----------------- Colonne droite : édition\n        Label(frame_right, text=\"Nom de la requête\", font=(\"Segoe UI\", 10, \"bold\")).pack(pady=2)\n        self.entry_query_name = ttk.Entry(frame_right, textvariable=self.var_query)\n        self.entry_query_name.pack(fill=\"x\", padx=5, pady=2)\n\n        Label(frame_right, text=\"Numéro de version\", font=(\"Segoe UI\", 10, \"bold\")).pack(pady=2)\n        self.entry_version = ttk.Entry(frame_right, textvariable=self.var_version)\n        self.entry_version.pack(fill=\"x\", padx=5, pady=2)\n\n        Label(frame_right, text=\"Contenu de la version\", font=(\"Segoe UI\", 10, \"bold\")).pack(pady=2)\n        frame_text = Frame(frame_right)\n        frame_text.pack(fill=BOTH, expand=True, padx=5, pady=2)\n\n        self.text_content = Text(frame_text, wrap=\"word\")\n        self.text_content.pack(side=LEFT, fill=BOTH, expand=True)\n        scroll_text = Scrollbar(frame_text, orient=\"vertical\", command=self.text_content.yview)\n        scroll_text.pack(side=RIGHT, fill=Y)\n        self.text_content.config(yscrollcommand=scroll_text.set)\n\n        btn_edit_bar = Frame(frame_right)\n        btn_edit_bar.pack(fill=\"x\", pady=4)\n        ttk.Button(btn_edit_bar, text=\"Enregistrer / Modifier\", command=self._on_save_version).pack(side=LEFT, padx=2)\n\n        btn_gen_bar = Frame(frame_right)\n        btn_gen_bar.pack(fill=\"x\", pady=4)\n        ttk.Button(btn_gen_bar, text=\"Copier requête GitHub\", command=self._on_generate_github).pack(side=LEFT, padx=2)\n        ttk.Button(btn_gen_bar, text=\"Copier requête Edge\", command=self._on_generate_edge).pack(side=LEFT, padx=2)\n\n    # ------------------------------------------------------------------ #\n    # Rafraîchissements\n    # ------------------------------------------------------------------ #\n\n    def _refresh_categories(self):\n        self.list_categories.delete(0, END)\n        for c in self.manager.get_categories():\n            self.list_categories.insert(END, c)\n\n    def _refresh_queries(self):\n        self.list_queries.delete(0, END)\n        if self.current_category:\n            names = self.manager.get_queries_for_category(self.current_category)\n        else:\n            names = self.manager.get_all_query_names()\n        for q in names:\n            self.list_queries.insert(END, q)\n\n    def _refresh_versions(self):\n        self.list_versions.delete(0, END)\n        if not (self.current_category and self.current_query):\n            return\n        for v in self.manager.get_versions_for_query(self.current_category, self.current_query):\n            self.list_versions.insert(END, v)\n\n    def _refresh_editor(self):\n        self.var_query.set(self.current_query or \"\")\n        self.var_version.set(self.current_version or \"\")\n\n        self.text_content.delete(\"1.0\", END)\n        if self.current_category and self.current_query and self.current_version:\n            content = self.manager.get_version_content(\n                self.current_category,\n                self.current_query,\n                self.current_version,\n            )\n            self.text_content.insert(\"1.0\", content)\n\n        self._select_in_list(self.list_queries, self.current_query)\n        self._select_in_list(self.list_versions, self.current_version)\n\n    def _select_in_list(self, listbox: Listbox, value: str | None):\n        listbox.selection_clear(0, END)\n        if not value:\n            return\n        for i in range(listbox.size()):\n            if listbox.get(i) == value:\n                listbox.selection_set(i)\n                listbox.activate(i)\n                break\n\n    # ------------------------------------------------------------------ #\n    # Événements sélection\n    # ------------------------------------------------------------------ #\n\n    def _on_category_selected(self, event=None):\n        sel = self.list_categories.curselection()\n        if not sel:\n            self.current_category = None\n        else:\n            self.current_category = self.list_categories.get(sel[0])\n        self.current_query = None\n        self.current_version = None\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_query_selected(self, event=None):\n        sel = self.list_queries.curselection()\n        if not sel:\n            self.current_query = None\n        else:\n            self.current_query = self.list_queries.get(sel[0])\n\n        versions = []\n        if self.current_category and self.current_query:\n            versions = self.manager.get_versions_for_query(self.current_category, self.current_query)\n        if versions:\n            if self.current_version not in versions:\n                self.current_version = versions[0]\n        else:\n            self.current_version = None\n\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_version_selected(self, event=None):\n        sel = self.list_versions.curselection()\n        if not sel:\n            self.current_version = None\n        else:\n            self.current_version = self.list_versions.get(sel[0])\n        self._refresh_editor()\n\n    # ------------------------------------------------------------------ #\n    # Actions catégories\n    # ------------------------------------------------------------------ #\n\n    def _on_add_category(self):\n        name = self._ask_string(\"Nouvelle catégorie\", \"Nom de la catégorie :\")\n        if not name:\n            return\n        self.manager.add_category(name)\n        self._refresh_categories()\n\n    def _on_rename_category(self):\n        if not self.current_category:\n            return\n        new = self._ask_string(\"Renommer catégorie\", \"Nouveau nom :\", initial=self.current_category)\n        if not new:\n            return\n        self.manager.rename_category(self.current_category, new)\n        self.current_category = new\n        self._refresh_categories()\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_delete_category(self):\n        if not self.current_category:\n            return\n        if not messagebox.askyesno(\"Supprimer\", f\"Supprimer la catégorie '{self.current_category}' et ses requêtes ?\"):\n            return\n        self.manager.delete_category(self.current_category)\n        self.current_category = None\n        self.current_query = None\n        self.current_version = None\n        self._refresh_categories()\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_import_categories(self):\n        path = filedialog.askopenfilename(\n            title=\"Importer catégories\",\n            filetypes=[(\"JSON\", \"*.json\"), (\"Tous fichiers\", \"*.*\")],\n        )\n        if not path:\n            return\n        self.manager.import_categories(path)\n        self._refresh_categories()\n\n    def _on_export_categories(self):\n        path = filedialog.asksaveasfilename(\n            title=\"Exporter catégories\",\n            defaultextension=\".json\",\n            filetypes=[(\"JSON\", \"*.json\"), (\"Tous fichiers\", \"*.*\")],\n        )\n        if not path:\n            return\n        self.manager.export_categories(path)\n\n    # ------------------------------------------------------------------ #\n    # Actions requêtes\n    # ------------------------------------------------------------------ #\n\n    def _on_add_query(self):\n        if not self.current_category:\n            messagebox.showerror(\"Erreur\", \"Sélectionnez d'abord une catégorie.\")\n            return\n        name = self._ask_string(\"Nouvelle requête\", \"Nom de la requête :\")\n        if not name:\n            return\n        self.manager.add_query(self.current_category, name)\n        self.current_query = name\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_rename_query(self):\n        if not (self.current_category and self.current_query):\n            return\n        new = self._ask_string(\"Renommer requête\", \"Nouveau nom :\", initial=self.current_query)\n        if not new:\n            return\n        self.manager.rename_query(self.current_category, self.current_query, new)\n        self.current_query = new\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_delete_query(self):\n        if not (self.current_category and self.current_query):\n            return\n        if not messagebox.askyesno(\"Supprimer\", f\"Supprimer la requête '{self.current_query}' ?\"):\n            return\n        self.manager.delete_query(self.current_category, self.current_query)\n        self.current_query = None\n        self.current_version = None\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_import_queries(self):\n        path = filedialog.askopenfilename(\n            title=\"Importer requêtes\",\n            filetypes=[(\"JSON\", \"*.json\"), (\"Tous fichiers\", \"*.*\")],\n        )\n        if not path:\n            return\n        self.manager.import_queries(path)\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_export_queries(self):\n        path = filedialog.asksaveasfilename(\n            title=\"Exporter requêtes\",\n            defaultextension=\".json\",\n            filetypes=[(\"JSON\", \"*.json\"), (\"Tous fichiers\", \"*.*\")],\n        )\n        if not path:\n            return\n        self.manager.export_queries(path)\n\n    # ------------------------------------------------------------------ #\n    # Actions versions\n    # ------------------------------------------------------------------ #\n\n    def _on_add_version(self):\n        if not (self.current_category and self.current_query):\n            messagebox.showerror(\"Erreur\", \"Sélectionnez d'abord une requête.\")\n            return\n        version = self._ask_string(\"Nouvelle version\", \"Numéro de version :\")\n        if not version:\n            return\n        content = self.text_content.get(\"1.0\", END).strip()\n        self.manager.set_version_content(self.current_category, self.current_query, version, content)\n        self.current_version = version\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_rename_version(self):\n        if not (self.current_category and self.current_query and self.current_version):\n            return\n        new_version = self._ask_string(\n            \"Renommer version\",\n            \"Nouveau numéro de version :\",\n            initial=self.current_version,\n        )\n        if not new_version:\n            return\n        new_content = self.text_content.get(\"1.0\", END).strip()\n        self.manager.rename_version(\n            self.current_category,\n            self.current_query,\n            self.current_version,\n            new_version,\n            new_content=new_content,\n        )\n        self.current_version = new_version\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_delete_version(self):\n        if not (self.current_category and self.current_query and self.current_version):\n            return\n        if not messagebox.askyesno(\"Supprimer\", f\"Supprimer la version '{self.current_version}' ?\"):\n            return\n        self.manager.delete_version(self.current_category, self.current_query, self.current_version)\n        self.current_version = None\n        self._refresh_versions()\n        self._refresh_editor()\n\n    def _on_save_version(self):\n        if not (self.current_category and self.current_query):\n            messagebox.showerror(\"Erreur\", \"Sélectionnez d'abord une requête.\")\n            return\n\n        new_query_name = self.var_query.get().strip()\n        new_version = self.var_version.get().strip()\n        content = self.text_content.get(\"1.0\", END).strip()\n\n        if new_query_name and new_query_name != self.current_query:\n            self.manager.rename_query(self.current_category, self.current_query, new_query_name)\n            self.current_query = new_query_name\n\n        if not self.current_version:\n            if not new_version:\n                messagebox.showerror(\"Erreur\", \"Numéro de version requis.\")\n                return\n            self.manager.set_version_content(self.current_category, self.current_query, new_version, content)\n            self.current_version = new_version\n        else:\n            if new_version and new_version != self.current_version:\n                self.manager.rename_version(\n                    self.current_category,\n                    self.current_query,\n                    self.current_version,\n                    new_version,\n                    new_content=content,\n                )\n                self.current_version = new_version\n            else:\n                self.manager.set_version_content(\n                    self.current_category,\n                    self.current_query,\n                    self.current_version,\n                    content,\n                )\n\n        self._refresh_queries()\n        self._refresh_versions()\n        self._refresh_editor()\n\n    # ------------------------------------------------------------------ #\n    # Génération via QueriesLogic\n    # ------------------------------------------------------------------ #\n\n    def _on_generate_github(self):\n        if not (self.current_query and self.current_version):\n            messagebox.showerror(\"Erreur\", \"Sélectionnez une requête et une version.\")\n            return\n        self.logic.generate_github_copilot(self.current_query, self.current_version)\n\n    def _on_generate_edge(self):\n        if not (self.current_query and self.current_version):\n            messagebox.showerror(\"Erreur\", \"Sélectionnez une requête et une version.\")\n            return\n        self.logic.generate_edge_copilot(self.current_query, self.current_version)\n\n    # ------------------------------------------------------------------ #\n    # Helpers\n    # ------------------------------------------------------------------ #\n\n    def _ask_string(self, title: str, prompt: str, initial: str = \"\") -> str | None:\n        from tkinter.simpledialog import askstring\n        return askstring(title, prompt, initialvalue=initial)\n",
    "interface\\__init__.py": "",
    "src\\client_logic.py": "import os\nimport subprocess\nfrom typing import List, Optional\nfrom src.server_logic import ServerLogic\n\n\nclass ClientLogic:\n    def __init__(self):\n        self.project_root: Optional[str] = None\n        self.server: Optional[ServerLogic] = None\n        self.selected_version: Optional[str] = None\n        self.selected_files: List[str] = []\n\n    # ---------- Projet ----------\n\n    def select_project(self, path: str) -> None:\n        self.project_root = path\n        self.server = ServerLogic(path)\n\n    def has_project(self) -> bool:\n        return self.server is not None\n\n    def open_project_folder(self) -> None:\n        if not self.project_root:\n            return\n        if os.name == \"nt\":  # Windows\n            os.startfile(self.project_root)\n        elif os.name == \"posix\":  # macOS / Linux\n            subprocess.Popen([\"open\" if sys.platform == \"darwin\" else \"xdg-open\", self.project_root])\n\n    # ---------- Extraction ----------\n\n    def extract_full_project(self) -> str:\n        if not self.server:\n            raise RuntimeError(\"Aucun projet sélectionné.\")\n        snapshot = self.server.scan_project()\n        self.server.save_snapshot(snapshot)\n        self.server.export_full_context(snapshot)\n        self.selected_version = snapshot.version\n        return snapshot.version\n\n    # ---------- Versions ----------\n\n    def get_available_versions(self) -> List[str]:\n        if not self.server:\n            return []\n        return self.server.list_versions()\n\n    def select_version(self, version: str) -> None:\n        self.selected_version = version\n\n    def delete_selected_version(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        self.server.delete_version(self.selected_version)\n        self.selected_version = None\n\n    # ---------- Fichiers ----------\n\n    def get_files_from_selected_version(self) -> List[str]:\n        if not self.server or not self.selected_version:\n            return []\n        snapshot = self.server.load_snapshot(self.selected_version)\n        return sorted(snapshot.files_content.keys())\n\n    def set_selected_files(self, files: List[str]) -> None:\n        self.selected_files = files\n\n    # ---------- Export sélection ----------\n\n    def export_selected_markdown_and_html(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.export_selected_context(snapshot, self.selected_files)\n\n    # ---------- Restauration ----------\n\n    def restore_full_version(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.restore_all(snapshot)\n\n    def restore_selected_files(self) -> None:\n        if not self.server or not self.selected_version:\n            return\n        snapshot = self.server.load_snapshot(self.selected_version)\n        self.server.restore_selected(snapshot, self.selected_files)\n",
    "src\\queries_logic.py": "import os\nimport webbrowser\nfrom typing import List, Dict, Callable, Optional\n\nfrom data.queries_manager import QueriesManager\n\n\nclass QueriesLogic:\n    def __init__(\n        self,\n        manager: QueriesManager,\n        copy_to_clipboard: Callable[[str], None],\n        get_selected_files: Callable[[], List[str]],\n        base_path: Optional[str] = None,\n    ):\n        self.manager = manager\n        self.copy_to_clipboard = copy_to_clipboard\n        self.get_selected_files = get_selected_files\n\n        if base_path is None:\n            base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n        self.base_path = base_path\n\n        self.context_html_path = os.path.join(\n            self.base_path,\n            \"code_source\",\n            \"selected_context.html\",\n        )\n\n    # ---------- Construction des requêtes ----------\n\n    def build_edge_query(self, query: Dict, version: Dict) -> str:\n        before = version.get(\"before\", \"\").strip()\n        after = version.get(\"after\", \"\").strip()\n\n        context_block = (\n            \"Interface: the context files are available in the @selected_context tab.\"\n        )\n\n        parts = [p for p in [before, context_block, after] if p]\n        return \"\\n\\n\".join(parts)\n\n    def build_github_query(self, query: Dict, version: Dict) -> str:\n        before = version.get(\"before\", \"\").strip()\n        after = version.get(\"after\", \"\").strip()\n\n        selected_files = self.get_selected_files()\n        if selected_files:\n            context_lines = [f\"@{path}\" for path in selected_files]\n            context_block = \"Context files:\\n\" + \"\\n\".join(context_lines)\n        else:\n            context_block = \"Context files: (no files selected)\"\n\n        parts = [p for p in [before, context_block, after] if p]\n        return \"\\n\\n\".join(parts)\n\n    # ---------- Actions ----------\n\n    def open_edge_context_html(self) -> None:\n        if os.path.exists(self.context_html_path):\n            webbrowser.open(self.context_html_path)\n\n    def generate_edge_copilot(self, query_name: str, version_number: str) -> str:\n        query = self.manager.get_query(query_name)\n        if query is None:\n            return \"\"\n        version = self.manager.get_version(query_name, version_number)\n        if version is None:\n            return \"\"\n        text = self.build_edge_query(query, version)\n        self.open_edge_context_html()\n        self.copy_to_clipboard(text)\n        return text\n\n    def generate_github_copilot(self, query_name: str, version_number: str) -> str:\n        query = self.manager.get_query(query_name)\n        if query is None:\n            return \"\"\n        version = self.manager.get_version(query_name, version_number)\n        if version is None:\n            return \"\"\n        text = self.build_github_query(query, version)\n        self.copy_to_clipboard(text)\n        return text\n",
    "src\\server_logic.py": "import os\nfrom typing import List, Dict, Tuple\nfrom data.models import ProjectPaths, ExclusionRules, ProjectSnapshot\nfrom data.utils import (\n    save_json,\n    load_json,\n    generate_markdown,\n    generate_html,\n    get_next_version_number,\n    list_existing_versions,\n    delete_version_files,\n)\n\n\nclass ServerLogic:\n    def __init__(self, project_root: str):\n        self.paths = ProjectPaths(project_root)\n        self.exclusions = ExclusionRules()\n        self._ensure_code_source()\n\n    # ---------- Initialisation / exclusions ----------\n\n    def _ensure_code_source(self) -> None:\n        os.makedirs(self.paths.code_source, exist_ok=True)\n        if not os.path.exists(self.paths.exclude_file):\n            with open(self.paths.exclude_file, \"w\", encoding=\"utf-8\") as f:\n                f.write(\"\\n\".join(sorted(self.exclusions.defaults)))\n\n    def load_exclusions(self) -> None:\n        self.exclusions.custom.clear()\n        if os.path.exists(self.paths.exclude_file):\n            with open(self.paths.exclude_file, \"r\", encoding=\"utf-8\") as f:\n                for line in f:\n                    line = line.strip()\n                    if line:\n                        self.exclusions.custom.add(line)\n\n    # ---------- Scan / snapshot ----------\n\n    def scan_project(self) -> ProjectSnapshot:\n        self.load_exclusions()\n        organisation: Dict[str, Dict[str, List[str]]] = {}\n        files_content: Dict[str, str] = {}\n\n        for current_root, dirs, files in os.walk(self.paths.root):\n            rel_root = os.path.relpath(current_root, self.paths.root)\n            if rel_root == \".\":\n                rel_root = \"\"\n\n            dirs[:] = [d for d in dirs if not self.exclusions.should_exclude(d)]\n\n            organisation[rel_root] = {\n                \"dirs\": dirs.copy(),\n                \"files\": [f for f in files if not self.exclusions.should_exclude(f)],\n            }\n\n            for f in files:\n                if self.exclusions.should_exclude(f):\n                    continue\n                rel_path = os.path.join(rel_root, f) if rel_root else f\n                file_path = os.path.join(current_root, f)\n                try:\n                    with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as fp:\n                        files_content[rel_path] = fp.read()\n                except Exception:\n                    files_content[rel_path] = \"<< Impossible de lire ce fichier >>\"\n\n        version = get_next_version_number(self.paths.code_source)\n        return ProjectSnapshot(version=version, organisation=organisation, files_content=files_content)\n\n    # ---------- Sauvegarde / chargement snapshot ----------\n\n    def save_snapshot(self, snapshot: ProjectSnapshot) -> None:\n        save_json(self.paths.organisation_json(snapshot.version), snapshot.organisation)\n        save_json(self.paths.files_content_json(snapshot.version), snapshot.files_content)\n\n    def load_snapshot(self, version: str) -> ProjectSnapshot:\n        org = load_json(self.paths.organisation_json(version))\n        fc = load_json(self.paths.files_content_json(version))\n        return ProjectSnapshot(version=version, organisation=org, files_content=fc)\n\n    # ---------- Exports ----------\n\n    def export_full_context(self, snapshot: ProjectSnapshot) -> None:\n        md = generate_markdown(snapshot)\n        html = generate_html(snapshot)\n        with open(self.paths.context_md, \"w\", encoding=\"utf-8\") as f:\n            f.write(md)\n        with open(self.paths.context_html, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n\n    def export_selected_context(self, snapshot: ProjectSnapshot, selected_files: List[str]) -> None:\n        from data.utils import filter_snapshot\n        filtered = filter_snapshot(snapshot, selected_files)\n        md = generate_markdown(filtered)\n        html = generate_html(filtered)\n        with open(self.paths.selected_context_md, \"w\", encoding=\"utf-8\") as f:\n            f.write(md)\n        with open(self.paths.selected_context_html, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n\n    # ---------- Versioning ----------\n\n    def list_versions(self) -> List[str]:\n        return list_existing_versions(self.paths.code_source)\n\n    def delete_version(self, version: str) -> None:\n        delete_version_files(self.paths.code_source, version)\n\n    # ---------- Restauration ----------\n\n    def restore_all(self, snapshot: ProjectSnapshot) -> None:\n        for rel_path, content in snapshot.files_content.items():\n            abs_path = os.path.join(self.paths.root, rel_path)\n            os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n            with open(abs_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n    def restore_selected(self, snapshot: ProjectSnapshot, selected_files: List[str]) -> None:\n        selected_set = set(selected_files)\n        for rel_path, content in snapshot.files_content.items():\n            if rel_path not in selected_set:\n                continue\n            abs_path = os.path.join(self.paths.root, rel_path)\n            os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n            with open(abs_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)",
    "src\\__init__.py": ""
}